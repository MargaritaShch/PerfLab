export const LoadTestingQuestions = [
  {
    id: 1,
    question: 'Что такое НТ? Что такое МНТ? Из каких разделов состоит?',
    answer: `
    <p><strong>Нагрузочное тестирование (НТ)</strong> — это один из видов тестирования производительности, при котором оценивается работа программного обеспечения под ожидаемой нагрузкой, посредством эмулиции действий большого кол-ва виртуальных пользователей.</p>

    <p><strong>Методика нагрузочного тестирования (МНТ)</strong> – согласованный с заказчиком документ, регламентирующий проводимые тесты, средства тестирования, профиль нагрузки, SLA (Service level agreement – соглашение о качестве предоставляемых услуг).</p>

    <p><strong>Разделы МНТ:</strong> </p>
      <ul>
      <li><strong>1.Объект тестирования:</strong> Общее описание системы, её назначения и структуры, включая архитектуру.</li>
      <li><strong>2.Цели испытаний:</strong> Определение ключевых целей, таких как установление максимальной пропускной способности системы, проверка стабильной работы в течение длительного времени, и выявление возможных узких мест в производительности.</li>
      <li><strong>3.Требования к производительности:</strong> Описание допустимых показателей системы, включая время отклика, уровень доступности, процент ошибок, а также утилизацию ресурсов, таких как CPU и RAM.</li>
      <li><strong>4.Сценарии нагрузочного тестирования:</strong> Перечень сценариев, которые отражают реальные случаи использования системы.</li>
      <li><strong>5.Нагрузочные испытания:</strong> Описание различных видов нагрузочных тестов, таких как тест на определение максимальной нагрузки и тесты стабильности.</li>
      <li><strong>6.Профили нагрузки:</strong> Указание интенсивности запросов, количества пользователей и интервалов между запросами.</li>
        <p><strong>Профиль нагрузки</strong> — это набор операций с заданными интенсивностями, полученный на основе сбора статистических данных либо определенный путем анализа требований к тестируемой системе.</p>
          <p><strong>Методы сбора профиля НТ:</strong></p>
          <ul>
            <li><strong>Анализ бизнес-требований:</strong> Сбор данных о прогнозируемом количестве пользователей и типичных сценариях использования.</li>
            <li><strong>Логирование реальных пользователей:</strong> Анализ логов реальных систем для определения характерных нагрузок.</li>
            <li><strong>Анализ мониторинга системы:</strong> Использование данных мониторинга производительности (например, Grafana, Prometheus) для понимания, как система работает под нагрузкой.</li>
            <li><strong>Консультации с разработчиками и бизнес-аналитиками:</strong> Определение критичных операций и нагрузочных сценариев.</li>
          </ul>
      <li><strong>7.Конфигурация стендов:</strong> Описание тестовых стендов, включая количество и параметры виртуальных машин, баз данных и сетевой инфраструктуры, используемой для проведения тестирования. Оборудование должно быть максимально приближено к продуктивной среде.</li>
      <li><strong>8.Средства нагрузочного тестирования:</strong> Описание используемых инструментов, таких как JMeter и другие средства, обеспечивающие генерацию нагрузки + заглушки.</li>
      <li><strong>9.Мониторинг:</strong> Описание системы мониторинга, используемой для отслеживания состояния системы и её ключевых метрик во время нагрузочного тестирования, включая ссылки на дашборды и метрики.</li>
      <li><strong>10.Отчеты и анализ:</strong> Описание процесса подготовки отчётов с результатами тестов, включая формат их предоставления.</li>
      <li><strong>11.Ограничения тестирования:</strong> Описание ограничений и допущений, которые необходимо учитывать при проведении тестирования, таких как несовершенства архитектуры или несоотвествие тестового и продового стендов.</li>
      <li><strong>12.Генерация данных:</strong> Подготовка тестовых данных, соответствующих структуре и объёму данных в рабочей среде.</li>

    <p><strong>Основные цели раздела "Генерация БД":</strong></p>
    <p>Для проведения нагрузочного тестирования важно создать реалистичные данные, имитирующие рабочие условия. Это включает создание большого объёма данных в базе, чтобы проверить производительность системы под нагрузкой. Генерация данных также помогает создать условия для тестирования сложных SQL-запросов и имитирует поведение реальных пользователей. Вот как это можно сделать:</p>
    
    <ol>
      <li><strong>Создание объёма данных:</strong> Генерируйте большое количество записей (например, пользователей, транзакций) для тестов, что помогает симулировать реальную работу системы под высокой нагрузкой. Используйте SQL-скрипты или инструменты для автоматической генерации записей.</li>

      <li><strong>Использование инструментов:</strong> Для генерации данных часто применяются инструменты, такие как <code>Faker</code> (для создания случайных данных), <code>JMeter</code> или <code>DataFactory</code> (для массового создания данных). Они могут генерировать тестовые наборы данных с различными параметрами.</li>

      <li><strong>Реалистичные данные:</strong> Убедитесь, что сгенерированные данные имеют связи между таблицами и индексы, чтобы тестирование было максимально приближено к реальной эксплуатации базы данных.</li>

      <li><strong>Тестирование сложных запросов:</strong> Если сценарий требует выполнения сложных SQL-запросов, создайте данные для тестирования производительности запросов, включая <code>JOIN</code>, <code>GROUP BY</code>, и другие операции.</li>

      <li><strong>Избежание дублирования данных:</strong> Генерация уникальных данных для каждого виртуального пользователя помогает избежать одних и тех же записей, что приближает тестирование к реальным условиям эксплуатации системы.</li>
    </ol>
    </ul>
      `,
    level: 'INTERN',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 2,
    question: 'Что нужно прописывать в отчёте?',
    answer: `
    <ul>
      <li><strong>1.Цели тестирования:</strong> Определение стабильности системы при постоянной нагрузке и выявление проблем производительности.</li>
      <li><strong>2.Выводы:</strong> Обобщение ключевых результатов тестирования, включая стабильность системы, время отклика, наличие ошибок, и способность системы выдерживать нагрузку.</li>
      <li><strong>3.Описание теста:</strong> Характеристика проведенного теста, включая сценарии нагрузки, длительность, RPS (запросы в секунду) и тип нагрузки.</li>
      <li><strong>4.Результаты тестирования:</strong> Представление данных о времени отклика, стабильности RPS, отсутствии ошибок и показателей производительности системы, таких как утилизация CPU и памяти.</li>
      <li><strong>5.Конфигурация среды для тестирования:</strong> Описание настроек стенда и ресурсов, используемых в тесте (например, количество реплик, ограничения по CPU и памяти), а также соответствие тестовой среды продуктивной.</li>
      <li><strong>6.Графики и ссылки:</strong> Ссылки на графики с метриками производительности, такие как использование ресурсов и производительность системы в течение теста.</li>
    </ul>
        `,
    level: 'INTERN',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 3,
    question: 'Что такое параметризация? Что такое корреляция?',
    answer: `
    <p><strong>Параметризация</strong> — это процесс использования переменных вместо фиксированных данных в запросах. Это позволяет запускать тест с различными значениями (например, разные логины) для симуляции реальных пользователей.</p>
    <p>Пример из моего проекта: В  файле JMeter используется User Defined Variables, где определены следующие переменные:</p>
    <ul>
      <li>protocol = https</li>
      <li>port = 443</li>
      <li>host = profit-test.finportal-dev-2.salt.x5.ru</li>
      <li>authHost = key-stage.x5.ru</li>
      <li>client_id = finportal</li>
      <li>username = [ваши данные]</li>
    </ul>
    <p>Эти переменные используются в запросах для построения URL и других параметров:</p>
    <pre><code>\${protocol}://\${host}:\${port}/api/v1/data</code></pre>
    <p>Таким образом, вместо фиксированного URL используются переменные, что облегчает изменение конфигурации и поддерживает гибкость тестирования.</p> 
    
    <p><strong>Корреляция</strong> — это извлечение динамических данных (например, токенов) из ответа одного запроса для последующего использования в другом запросе. Это необходимо, когда система генерирует уникальные данные для каждой сессии.</p>
    <p>Пример из моего проекта: Предположим, что сервер возвращает токен авторизации в одном из запросов, который нужно использовать в дальнейшем для аутентификации. Для этого используется JSON Extractor:</p>
    <ol>
      <li>Добавьте JSON Extractor в запрос, где возвращается токен:
        <ul>
          <li>JSON Path: <code>$.access_token</code></li>
          <li>Имя переменной: <code>accessToken</code></li>
        </ul>
      </li>
      <li>В следующих запросах используйте переменную для передачи токена:
        <pre><code>Authorization: Bearer \${accessToken}</code></pre>
      </li>
    </ol>
    <p>Теперь токен будет автоматически подставляться в каждый новый запрос, обеспечивая корректную работу теста.</p>`,
    level: 'INTERN',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 4,
    question: 'Как записать простой скрипт с помощью Recording в JMeter? Основные шаги настройки скрипта в JMeter после записи?',
    answer: `
          <ul>
            <li><strong>Открой JMeter</strong> и добавь HTTP(S) Test Script Recorder.</li>
            <li><strong>Настрой прокси-сервер</strong> для захвата трафика (укажи порт).</li>
            <li><strong>Добавь Thread Group</strong> для организации сценария.</li>
            <li><strong>Запусти запись</strong> и проведи необходимые действия в браузере/приложении.</li>
            <li><strong>Останови запись</strong> — все запросы будут сохранены в виде шагов в сценарии.</li>
          </ul>

          <p><strong>Основные шаги настройки скрипта в JMeter после записи:</strong></p>
          <ol>
          <li><strong>Очистка скрипта:</strong>
            <ul>
              <li>Удалите ненужные запросы (статические ресурсы: CSS, JS, изображения).</li>
              <li>Группируйте запросы с помощью Transaction Controller для удобства и измерения времени выполнения транзакций.</li>
            </ul>
          </li>

          <li><strong>Параметризация:</strong>
            <ul>
              <li>Используйте CSV Data Set Config для замены статических данных (логины, пароли) на динамические переменные из файла.</li>
              <li>Пример:
                <pre>
                  POST /login
                  {
                    "username": "\${username}",
                    "password": "\${password}"
                  }
                </pre>
              </li>
            </ul>
          </li>

          <li><strong>Корреляция:</strong>
            <ul>
              <li>Извлекайте динамические данные (например, токены) с помощью Regular Expression Extractor или JSON Extractor.</li>
              <li>Пример регулярного выражения: <code>"sessionId":"(.+?)"</code>.</li>
            </ul>
          </li>

          <li><strong>Добавление тайм-аутов (Think Time):</strong>
            <ul>
              <li>Добавьте паузы между запросами с помощью Constant Timer или Uniform Random Timer для симуляции реального поведения пользователей.</li>
            </ul>
          </li>

          <li><strong>Пейсинг:</strong>
            <ul>
              <li>Установите интервал между началом выполнения каждого сценария, чтобы моделировать задержку между действиями пользователей.</li>
              <li>Пейсинг можно настроить с помощью JSR223 Sampler или Timers, рассчитывая время до следующего запуска сценария.</li>
              <li>Пример: если сценарий выполняется за 30 секунд, а требуется запускать его каждые 60 секунд, добавьте таймер на 30 секунд между выполнениями.</li>
            </ul>
          </li>

          <li><strong>Настройка Thread Group:</strong>
            <ul>
              <li>Установите количество пользователей (Number of Threads), время разгона (Ramp-Up Period) и количество повторений сценария (Loop Count).</li>
            </ul>
          </li>

          <li><strong>Проверки (Assertions):</strong>
            <ul>
              <li>Добавьте Response Assertion для проверки кода ответа или содержания ответа, чтобы убедиться, что запросы успешны.</li>
            </ul>
          </li>

          <li><strong>Сбор метрик (Listeners):</strong>
            <ul>
              <li>Используйте Summary Report, View Results Tree для сбора метрик по времени отклика, проценту ошибок и другим параметрам.</li>
            </ul>
          </li>
      </ol>
        `,
    level: 'INTERN',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 5,
    question: 'Виды проверок в JMeter',
    answer: `
      <ol>
      <li><strong>Response Assertion:</strong>
        <p>Применяется для проверки ответа от сервера. Позволяет проверять код ответа HTTP, тело ответа, заголовки и сообщения об ошибках.</p>
        <ul>
          <li>Поиск текста — проверка на наличие или отсутствие конкретного текста в ответе.</li>
          <li>Регулярные выражения — гибкий поиск данных в теле ответа.</li>
          <li>Коды ответов — проверка HTTP статус-кодов, например, 200 OK.</li>
        </ul>
      </li>
      
      <li><strong>Size Assertion:</strong>
        <p>Проверяет, что размер тела ответа меньше или больше указанного значения.</p>
        <pre><code>Пример: Проверка, что размер тела ответа меньше 5000 байт</code></pre>
      </li>
      
      <li><strong>Duration Assertion:</strong>
        <p>Проверяет, что запрос выполнен за определенное время.</p>
        <pre><code>Пример: Запрос должен быть выполнен за 2 секунды</code></pre>
      </li>
      
      <li><strong>XPath Assertion:</strong>
        <p>Проверяет содержимое XML-ответа с помощью XPath.</p>
        <pre><code>Пример: Проверка, что XML-ответ содержит элемент <status>Success</status></code></pre>
      </li>
      
      <li><strong>JSON Assertion:</strong>
        <p>Проверка содержимого JSON-ответов.</p>
        <pre><code>Пример: Проверка, что JSON-ответ содержит поле "status": "Success"</code></pre>
      </li>
    </ol>
        `,
    level: 'INTERN',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 6,
    question: 'Что такое пейсинг? Как правильно вычислять пейсинг и количество пользователей?',
    answer: `
      <p>Пейсинг — это интервал времени между выполнением последовательных действий одного и того же виртуального пользователя в нагрузочном тесте. Пейсинг контролирует интенсивность нагрузки.</p>
          <p>Формула пейсинга:</p>
          <pre><code>
            Пейсинг = (60 / Целевая нагрузка) - Время выполнения сценария
          </code></pre>
          <p>Пример:</p>
          <ul>
            <li>Целевая нагрузка: 1000 запросов в минуту</li>
            <li>100 пользователей</li>
            <li>Среднее время выполнения: 5 секунд</li>
          </ul>

      <p><strong>Как рассчитать количество пользователей:</strong></p>
        <p>Количество пользователей определяется исходя из целевой нагрузки (RPS) и времени выполнения сценария:</p>
        <pre><code>
          Количество пользователей = (RPS * Время выполнения сценария)
        </code></pre>
        <p>Где:</p>
        <ul>
          <li><strong>RPS (Requests Per Second)</strong> — количество запросов в секунду, которое система должна обрабатывать.</li>
          <li><strong>Время выполнения сценария</strong> — время, необходимое для выполнения одного цикла действий пользователя.</li>
        </ul>
    <p>Пример расчета:</p>
    <ul>
      <li>Целевая нагрузка: 0.14 RPS</li>
      <li>Среднее время выполнения сценария: 5 секунд</li>
      <li>Количество пользователей = 0.14 * 5 = 0.7 (округляем до 1 пользователя)</li>
    </ul>
    <p>Таким образом, при расчете количества пользователей важно учитывать целевую нагрузку и среднее время выполнения сценария, чтобы правильно распределить нагрузку и добиться реалистичного моделирования поведения пользователей в тесте.</p>
          `,
    level: 'JUNIOR',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 7,
    question:
      'Что такое пулы данных в нагрузочном тестировании и как их использовать?',
    answer: `
        <p>Пулы данных — это наборы данных, которые используются для параметризации запросов в тестах, чтобы симулировать различные входные данные и избежать отправки однотипных запросов.</p>
        <p><strong>Зачем нужны пулы данных:</strong></p>
        <ul>
          <li>Они позволяют разнообразить запросы, обеспечивая более реалистичное тестирование.</li>
          <li>Помогают избежать кэширования запросов.</li>
          <li>Используются для тестирования больших объёмов данных.</li>
        </ul>
        <p><strong>Как использовать пулы данных в нагрузочном тестировании:</strong></p>
        <ol>
          <li>Подготовьте пул данных в виде файла (например, CSV).</li>
          <li>Настройте инструменты (JMeter, Locust) для использования данных из этого файла.</li>
        </ol>
        <p>Пример использования пула данных в JMeter:</p>
        <pre><code>
          user1,password1
          user2,password2
          user3,password3
        </code></pre>
      `,
    level: 'MIDDLE',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 8,
    question: 'Что такое сущность в БД?',
    answer: `
           <p>Сущность в базе данных (БД) — это объект или концепция, которая представляет собой некоторую информацию, которую необходимо хранить в системе. В контексте реляционных баз данных сущность обычно отображается в виде таблицы, где каждая строка представляет собой запись (экземпляр сущности), а столбцы — атрибуты (свойства) сущности.</p>
    
    <h4>Основные характеристики сущности:</h4>
    <ol>
      <li>Сущность — это объект, который может быть идентифицирован в системе. Примеры сущностей: пользователи, заказы, товары, транзакции и т.д.</li>
      <li>Атрибуты сущности — это характеристики, которые описывают сущность. Например, сущность "Пользователь" может иметь атрибуты, такие как имя, электронная почта, возраст и т.д.</li>
      <li>Экземпляры сущности — это конкретные записи в таблице базы данных. Например, каждый пользователь в таблице "Пользователи" — это экземпляр сущности "Пользователь".</li>
    </ol>
    
    <h4>Пример:</h4>
    <p>Для сущности "Пользователь" может быть создана таблица в базе данных, которая содержит следующие атрибуты:</p>
    <ul>
      <li>id (идентификатор пользователя),</li>
      <li>first_name (имя),</li>
      <li>last_name (фамилия),</li>
      <li>email (электронная почта).</li>
    </ul>
    
    <h4>Пример таблицы "Пользователи":</h4>
    <pre><code>id   first_name  last_name  email
1    Иван        Иванов     ivan@example.com
2    Ольга       Смирнова   olga@example.com
    </code></pre>
    
    <p>В данном случае сущность — это "Пользователь", а каждая строка таблицы представляет собой конкретного пользователя, то есть экземпляр этой сущности.</p>
    
    <h4>Заключение:</h4>
    <p>Сущность — это ключевая концепция в базах данных, которая отражает объекты, с которыми работает система, и хранит информацию о них в виде записей (строк) в таблицах.</p
        `,
    level: 'JUNIOR',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    "id": 9,
    "question": "Парсинг логов это? Делала ли ты парсинг логов?",
    "answer": `
       <p>Этот лог-парсер создан для анализа активности в системе по файлу логов. Он позволяет получить статистику использования отдельных HTTP-методов, определить время пиковых нагрузок и рассчитать метрики для дальнейшего тестирования. Вот краткое описание его работы:</p>

<h3>Цели парсера:</h3>
<ul>
    <li>Обработка логов для подсчета запросов к ключевым API-методам.</li>
    <li>Определение количества запросов в секунду (RPS), запросов в минуту (RPM) и расчета пейсинга для каждого метода.</li>
    <li>Генерация конфигураций на основе собранных данных для инструмента нагрузочного тестирования JMeter.</li>
</ul>

<h3>Основные компоненты:</h3>

<p><strong>Main.java:</strong> Этот класс является точкой входа в программу. Он запускает процесс анализа логов, считывая данные из лог-файлов. В результате:</p>
<ul>
    <li>Создает объект Parser, который выполняет парсинг файла логов и собирает статистику по релевантным HTTP-методам и путям.</li>
    <li>После завершения парсинга выводит общую статистику запросов, а также пиковый час, чтобы выделить временной интервал с наибольшей активностью.</li>
    <li>Рассчитывает пейсинг (интервалы между запросами) и создает конфигурацию для JMeter на основе собранных данных, что упрощает дальнейшую настройку нагрузочного тестирования.</li>
</ul>

<p><strong>Parser.java:</strong> Это основной класс, который отвечает за чтение и обработку логов.</p>
<ul>
    <li>Построчно читает лог-файл, извлекая для каждого запроса временную метку, HTTP-метод и путь.</li>
    <li>Проводит проверку на релевантность запроса, то есть проверяет, относится ли запрос к ключевым методам и путям, заданным в настройках.</li>
    <li>Обновляет статистику в RequestStatistics, добавляя данные о каждом релевантном запросе (например, увеличивая счетчик вызовов для соответствующего метода и часа).</li>
</ul>

<p><strong>RequestStatistics.java:</strong> Этот класс собирает и управляет статистикой по всем релевантным запросам.</p>
<ul>
    <li>Ведет учет общего количества запросов для каждого метода и часа, а также поддерживает агрегированную статистику.</li>
    <li>Рассчитывает интенсивность запросов — RPS (Requests per Second) и RPM (Requests per Minute) для каждого метода.</li>
    <li>Определяет пиковый час, то есть час, когда система обрабатывала наибольшее количество запросов.</li>
    <li>Генерирует пейсинг — расчет интервалов между запросами для настройки JMeter, что помогает равномерно распределить нагрузку.</li>
    <li>Формирует конфигурацию для JMeter на основе собранных данных, задавая необходимые интервалы и интенсивность запросов для тестирования.</li>
</ul>

<h3>Ключевые метрики:</h3>
<ul>
    <li><strong>Общее количество вызовов:</strong> общий подсчет запросов к указанным API-методам.</li>
    <li><strong>RPS и RPM:</strong> интенсивность запросов (в секунду и в минуту), важная для планирования нагрузки.</li>
    <li><strong>Пиковый час:</strong> временной интервал с наибольшей нагрузкой, полезный для настройки JMeter.</li>
    <li><strong>Пейсинг:</strong> время между запросами для оптимального распределения нагрузки.</li>
</ul>
    `,
    "level": "MIDDLE",
    "category": "load",
    "title": "Performance engineer"
  },
  {
    id: 10,
    question:
      'Основные серверные метрики, на которые смотрят в Grafana при нагрузочном тестировании',
    answer: `
        <h2>Основные Серверные Метрики и Возможные Проблемы</h2>

        <h3>CPU Usage (Использование процессора)</h3>
        <ul>
            <li><strong>CPU Load (Нагрузка на процессор):</strong> средняя нагрузка на процессор, измеряется в единицах нагрузки (например, значение 1.0 для одного ядра означает, что нагрузка равна 100% его мощности).
                <ul>
                    <li><em>Проблемы:</em> Если нагрузка consistently превышает 70–80% от его мощности, это может указывать на перегрузку, что приводит к замедлению системы.</li>
                    <li><em>Причины:</em> Слишком много процессов пытаются одновременно использовать процессор, неэффективное использование ресурсов или ошибки в коде, вызывающие избыточные вычисления.</li>
                </ul>
            </li>
            <li><strong>CPU Utilization (Занятость процессора):</strong> процент времени, в течение которого процессор занят, измеряется в процентах (%).
                <ul>
                    <li><em>Проблемы:</em> Постоянная высокая занятость (выше 80%) может привести к замедлению отклика системы и общей деградации производительности.</li>
                    <li><em>Причины:</em> Недостаток процессорных ядер, чрезмерная нагрузка со стороны приложений или фоновых процессов.</li>
                </ul>
            </li>
            <li><strong>Context Switches (Переключения контекста):</strong> количество переключений между задачами, измеряется в количестве переключений в секунду (переключения/сек).
                <ul>
                    <li><em>Проблемы:</em> Слишком много переключений приводит к увеличению нагрузки на процессор, снижению его производительности и замедлению выполнения задач.</li>
                    <li><em>Причины:</em> Чрезмерное количество процессов или потоков, активно конкурирующих за ресурсы процессора, что увеличивает нагрузку на ОС.</li>
                </ul>
            </li>
        </ul>

        <h3>Memory Usage (Использование памяти)</h3>
        <ul>
            <li><strong>Memory Utilization (Занятость памяти):</strong> процент занятой оперативной памяти, измеряется в процентах (%).
                <ul>
                    <li><em>Проблемы:</em> Высокая занятость (90% и выше) может вызвать недостаток памяти для новых задач и привести к снижению производительности из-за подкачки.</li>
                    <li><em>Причины:</em> Утечки памяти в приложениях, высокий объем данных или неправильно настроенные процессы.</li>
                </ul>
            </li>
            <li><strong>Swap Usage (Использование подкачки):</strong> объем занятой подкачки, измеряется в мегабайтах (МБ) или процентах (%) от всего объема подкачки.
                <ul>
                    <li><em>Проблемы:</em> Чрезмерное использование подкачки замедляет систему, так как чтение с диска происходит гораздо медленнее, чем из оперативной памяти.</li>
                    <li><em>Причины:</em> Недостаток оперативной памяти для работы активных процессов или утечки памяти.</li>
                </ul>
            </li>
        </ul>

        <h3>Disk Usage (Использование диска)</h3>
        <ul>
            <li><strong>Disk Read/Write (Операции чтения/записи на диск):</strong> количество данных, читаемых и записываемых на диск, измеряется в мегабайтах в секунду (МБ/с) или гигабайтах в секунду (ГБ/с).
                <ul>
                    <li><em>Проблемы:</em> Высокая частота операций может привести к износу диска и снижению скорости операций из-за перегрузки.</li>
                    <li><em>Причины:</em> Интенсивная запись и чтение данных, вызванные обработкой больших объемов или неэффективными операциями на уровне БД.</li>
                </ul>
            </li>
            <li><strong>Disk I/O Utilization (Занятость диска):</strong> процент времени, в течение которого диск занят операциями ввода-вывода, измеряется в процентах (%).
                <ul>
                    <li><em>Проблемы:</em> Высокая занятость (80% и выше) указывает на перегрузку, которая может вызвать задержки во всех операциях, требующих доступ к диску.</li>
                    <li><em>Причины:</em> Чрезмерное количество запросов к диску, большие объемы записи или чтения, недостаточная скорость дисков.</li>
                </ul>
            </li>
            <li><strong>Disk Space Utilization (Занятость пространства на диске):</strong> занятое и доступное пространство на диске, измеряется в гигабайтах (ГБ) или процентах (%).
                <ul>
                    <li><em>Проблемы:</em> При заполнении диска (90% и более) система может перестать выполнять операции записи, что вызовет ошибки или зависания.</li>
                    <li><em>Причины:</em> Неэффективное использование пространства, отсутствие автоматической очистки данных.</li>
                </ul>
            </li>
        </ul>

        <h3>Network Usage (Использование сети)</h3>
        <ul>
            <li><strong>Network In/Out (Входящий и исходящий трафик):</strong> объем данных, проходящих через сетевой интерфейс, измеряется в мегабайтах в секунду (МБ/с) или гигабайтах в секунду (ГБ/с).
                <ul>
                    <li><em>Проблемы:</em> Высокий объем трафика может привести к перегрузке сети, потере пакетов и увеличению задержек.</li>
                    <li><em>Причины:</em> Повышенная нагрузка от клиентов, утечки данных или неэффективные сетевые операции.</li>
                </ul>
            </li>
            <li><strong>Network Errors (Сетевые ошибки):</strong> количество ошибок передачи данных, измеряется в количестве ошибок в секунду (ошибки/сек).
                <ul>
                    <li><em>Проблемы:</em> Ошибки связи указывают на проблемы с подключением, которые могут привести к недоступности сервисов или потере данных.</li>
                    <li><em>Причины:</em> Проблемы с сетевыми настройками, плохое качество соединения или перегрузка сети.</li>
                </ul>
            </li>
        </ul>

        <h3>Request Rate (Частота запросов)</h3>
        <ul>
            <li><strong>HTTP Requests per Second (Количество HTTP-запросов в секунду):</strong> измеряется в запросах в секунду (запросы/сек).
                <ul>
                    <li><em>Проблемы:</em> Слишком высокая частота запросов может перегрузить сервер, вызывая задержки и отказ в обслуживании.</li>
                    <li><em>Причины:</em> Внезапный рост количества пользователей, неэффективное распределение нагрузки или атаки на систему.</li>
                </ul>
            </li>
            <li><strong>Error Rate (Частота ошибок):</strong> процент ошибок среди всех запросов, измеряется в процентах (%).
                <ul>
                    <li><em>Проблемы:</em> Высокий процент ошибок в запросах может указывать на проблемы с сервером или сетью, снижающие доступность сервиса.</li>
                    <li><em>Причины:</em> Сбои в работе приложения, сетевые проблемы или некорректные запросы.</li>
                </ul>
            </li>
        </ul>

        <h3>Latency (Задержка)</h3>
        <ul>
            <li><strong>Response Time (Время ответа):</strong> среднее время ответа сервера на запрос, измеряется в миллисекундах (мс).
                <ul>
                    <li><em>Проблемы:</em> Увеличение времени ответа ведет к снижению производительности и ухудшению пользовательского опыта.</li>
                    <li><em>Причины:</em> Низкая производительность сервера, перегрузка CPU или высокая занятость диска.</li>
                </ul>
            </li>
        </ul>

        <h3>System Load (Нагрузка на систему)</h3>
        <ul>
            <li><strong>System Load Average (Средняя нагрузка на систему):</strong> средняя нагрузка за 1, 5 и 15 минут, измеряется в единицах нагрузки (например, значение 1.0 для одного ядра означает, что нагрузка равна 100% его мощности).
                <ul>
                    <li><em>Проблемы:</em> Значение нагрузки, превышающее количество ядер (например, 4 для 4-ядерного процессора), указывает на перегрузку и может вызвать задержки.</li>
                    <li><em>Причины:</em> Чрезмерное количество задач, активно конкурирующих за ресурсы CPU.</li>
                </ul>
            </li>
        </ul>
        `,
    level: 'INTERN',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 11,
    question: 'Анализ базы данных? Отчет AWR или pg_stat_statements?',
    answer: `
           <p><strong>Анализ базы данных</strong> в контексте нагрузочного тестирования включает оценку производительности баз данных под высокой нагрузкой. Основные задачи анализа:</p>
           <p><strong>Для анализа работы с базой данных PostgreSQL</strong> можно использовать <code>pg_stat_activity</code> и <code>pg_stat_statements</code>. Вот как их применяют для выявления проблем и оптимизации запросов:</p>

        <h3>1. pg_stat_activity — мониторинг активности</h3>
        <p><code>pg_stat_activity</code> предоставляет информацию обо всех текущих соединениях к базе данных и выполняющихся запросах. С помощью него можно:</p>
        <ul>
            <li>Увидеть активные соединения, их статус (выполняется ли запрос, ожидает, завершен), а также время, которое соединение работает.</li>
            <li>Отследить "тяжелые" запросы, занимающие много ресурсов, или запросы, находящиеся в состоянии ожидания.</li>
            <li>Выявить запросы, которые "висят" долгое время, создавая блокировки, и понять, откуда идет нагрузка.</li>
        </ul>
        <p><strong>Пример использования:</strong></p>
        <pre><code>SELECT pid, usename, application_name, state, query, wait_event_type, query_start 
FROM pg_stat_activity 
WHERE state = 'active';</code></pre>
        <p>Это позволяет увидеть активные запросы и узнать, какие процессы создают наибольшую нагрузку на базу данных, чтобы можно было своевременно оптимизировать их выполнение.</p>

        <h3>2. pg_stat_statements — сбор статистики по запросам</h3>
        <p><code>pg_stat_statements</code> используется для анализа производительности запросов, собирая статистику по всем выполненным запросам. Эта статистика включает количество запусков каждого запроса, среднее время выполнения и количество возвращенных строк.</p>
        <p><code>pg_stat_statements</code> помогает понять, какие запросы выполняются часто и занимают много ресурсов, а значит, нуждаются в оптимизации.</p>
        <p><strong>Пример использования:</strong></p>
        <pre><code>SELECT query, calls, total_time, mean_time, rows 
FROM pg_stat_statements 
ORDER BY total_time DESC 
LIMIT 10;</code></pre>
        <p>Это позволяет увидеть запросы, которые тратят больше всего времени на выполнение, и выбрать их для анализа на предмет оптимизации.</p>

        <h3>Работа с индексами и анализ с EXPLAIN и EXPLAIN ANALYZE</h3>
        <p>Индексы значительно ускоряют выборку данных, создавая структуру для быстрого поиска по заданным полям. Например, индекс на колонку <code>user_id</code> в таблице ускоряет выполнение запросов, фильтрующих или сортирующих данные по <code>user_id</code>.</p>

        <h4>EXPLAIN — анализ плана выполнения</h4>
        <p>Команда <code>EXPLAIN</code> показывает план выполнения SQL-запроса без его фактического выполнения. Она позволяет понять, как оптимизатор PostgreSQL планирует выполнять запрос — например, какие индексы будут использоваться.</p>
        <p>С помощью <code>EXPLAIN</code> можно проверить, используются ли созданные индексы в запросах, и, если нет, внести изменения в запрос или индексы.</p>
        <p><strong>Пример использования:</strong></p>
        <pre><code>EXPLAIN SELECT * FROM orders WHERE user_id = 123;</code></pre>
        <p>Это покажет, планирует ли PostgreSQL использовать индекс на <code>user_id</code> при выборке данных. Если нет, возможно, индекс создан неверно, или запрос нужно переписать.</p>

        <h4>EXPLAIN ANALYZE — анализ фактического выполнения</h4>
        <p><code>EXPLAIN ANALYZE</code> выполняет запрос и показывает фактический план выполнения с реальными показателями времени и количества обработанных строк.</p>
        <p>С помощью <code>EXPLAIN ANALYZE</code> можно проверить, насколько эффективно работают индексы и какие этапы выполнения занимают больше всего времени. Это особенно важно при оптимизации сложных запросов.</p>
        <p><strong>Пример использования:</strong></p>
        <pre><code>EXPLAIN ANALYZE SELECT * FROM orders WHERE user_id = 123;</code></pre>
        <p>Результат покажет, сколько времени потребовалось на выполнение каждого этапа, что позволяет оценить, насколько эффективно запрос использует индекс и есть ли "узкие места" в плане выполнения.</p>

        <h4>Почему важно использовать индексы с EXPLAIN и EXPLAIN ANALYZE</h4>
        <p>Индексы ускоряют выполнение запросов, но не всегда оптимизатор их выбирает. <code>EXPLAIN</code> помогает понять, какие индексы использует планировщик, а <code>EXPLAIN ANALYZE</code> — подтверждает, насколько это ускоряет запрос. Таким образом, можно увидеть, есть ли смысл добавлять индексы или изменять их для улучшения производительности.</p>

        <h2>Пример выполнения задания</h2>
         <p><strong>Анализ базы данных</strong> в контексте нагрузочного тестирования включает оценку производительности баз данных под высокой нагрузкой. Основные задачи анализа:</p>
        
        <p><strong>Цель профилирования:</strong> Целью данного профилирования является выявление и устранение узких мест в производительности базы данных, а также оптимизация медленно выполняющихся запросов для сокращения времени их выполнения и снижения нагрузки на ресурсы системы. Профилирование помогает лучше понять, какие запросы требуют наибольших затрат времени и ресурсов, чтобы можно было улучшить их выполнение с помощью индексации и других методов оптимизации.</p>

        <h3>Шаги выполнения задания</h3>
        <h4>Инициализация базы данных и подготовка данных</h4>
        <p>Запущен скрипт <code>sql_init.sql</code> для создания таблицы <code>test_v2</code> и заполнения ее 5 миллионами записей.</p>

        <h4>Запуск нового JAR-файла и тестовый запрос</h4>
        <p>Новый JAR-файл был успешно развернут на порту 8080. После этого выполнен тестовый запрос <code>GET localhost:8080/test/query</code>, и зафиксировано исходное время выполнения.</p>

        <h4>Настройка pg_stat_statements</h4>
        <p>Настроен плагин <code>pg_stat_statements</code> для отслеживания выполнения запросов в PostgreSQL.</p>

        <h4>Анализ медленных запросов</h4>
        <p>Используя <code>pg_stat_statements</code>, обнаружен наиболее медленно выполняющийся запрос:</p>
        <pre><code>SELECT * FROM foo ORDER BY c1;</code></pre>
        <p><strong>Причины замедления:</strong> Запрос выполнял сортировку по полю <code>c1</code>, загружая все данные из таблицы, что создавало высокую нагрузку на память и замедляло работу. Использование <code>SELECT *</code> привело к загрузке всех полей, что замедлило выполнение.</p>
        <p><strong>Исходное состояние:</strong> Запрос выполнялся через параллельный последовательный скан с последующей сортировкой на диске, что приводило к высокой нагрузке на дисковую систему и увеличивало время выполнения.</p>

        <h4>Оптимизация</h4>
        <p>Для оптимизации был создан индекс по полю <code>c1</code>, что позволило значительно ускорить выполнение сортировки:</p>
        <pre><code>CREATE INDEX idx_foo_c1 ON foo(c1);</code></pre>
        <p>Благодаря этому индексу запрос перешел от последовательного сканирования к индексному сканированию, что уменьшило объем работы для каждого выполнения запроса.</p>

        <h4>Результаты оптимизации</h4>
        <ul>
            <li><strong>Исходное время выполнения:</strong> 31,230 мс.</li>
            <li><strong>Время выполнения после оптимизации:</strong> 24,140 мс.</li>
            <li><strong>Улучшение производительности:</strong> Оптимизация уменьшила время выполнения на 22,7%.</li>
        </ul>

        <h3>Заключение</h3>
        <p>Оптимизация с помощью индекса позволила значительно сократить время выполнения запроса <code>SELECT * FROM foo ORDER BY c1</code>. Переход к индексному сканированию позволил уменьшить нагрузку на дисковую систему и оптимизировать распределение ресурсов при выполнении запросов к базе данных.</p>

        <h4>Сброс статистики</h4>
        <p>Для сброса статистики в <code>pg_stat_statements</code> 
        `,
    level: 'INTERN',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 12,
    question: 'Что такое многопоточность? Какой есть редел в потоках у приложения? Что такое поток?',
    answer: `
      <p><strong>Многопоточность</strong> — это способность программы или системы выполнять несколько потоков (или задач) одновременно. Каждый поток представляет собой отдельный поток выполнения внутри процесса и может работать независимо от других потоков. В контексте нагрузочного тестирования многопоточность позволяет имитировать большое количество пользователей, отправляющих запросы к системе одновременно.</p>

        <h3>Основные понятия о многопоточности:</h3>
        <ul>
            <li><strong>Поток:</strong> Единица выполнения внутри процесса. Каждый поток работает независимо, но разделяет память и ресурсы процесса.</li>
            <li><strong>Параллелизм:</strong> Возможность одновременного выполнения нескольких потоков на разных ядрах процессора.</li>
            <li><strong>Конкурентность:</strong> Одновременное выполнение нескольких задач, которые могут переключаться между собой, используя общее время процессора, даже на одном ядре.</li>
        </ul>

        <h3>Многопоточность и база данных (БД):</h3>
        <p>В нагрузочном тестировании, когда множество потоков отправляют запросы к БД одновременно, важно понимать, как эти запросы обрабатываются и как происходит взаимодействие между потоками и БД.</p>

        <h4>Взаимодействие потоков с БД (коннекты):</h4>
        <ul>
            <li><strong>Подключения (коннекты):</strong> Каждый поток должен установить соединение с БД для выполнения запроса. Это подключение называют коннектом. Как правило, каждый поток может создавать отдельное соединение с БД, чтобы отправить запросы на чтение или запись данных.</li>
            <li><strong>Пул соединений (Connection Pool):</strong> Чтобы эффективно управлять подключениями, используют пул соединений. Это набор предсозданных коннектов, которые повторно используются потоками. Пул помогает:
                <ul>
                    <li>Уменьшить накладные расходы на создание/закрытие соединений.</li>
                    <li>Избежать ситуации, когда слишком много потоков одновременно создают коннекты, что может перегрузить БД.</li>
                </ul>
            </li>
            <li><strong>Блокировки:</strong> Когда несколько потоков пытаются одновременно обновить одни и те же данные, возникает проблема блокировок. Блокировки помогают избежать конфликтов, когда один поток меняет данные, а другой пытается к ним обратиться.</li>
            <li><strong>Транзакции:</strong> Группы операций, выполняемых как единое целое. При работе с несколькими потоками важно, чтобы транзакции не мешали друг другу, иначе это может привести к потерям данных или нарушению их целостности.</li>
        </ul>
        <h3>Ограничения потоков и коннектов</h3>
        <p>Количество потоков и подключений (коннектов) к базе данных ограничено и зависит от различных факторов:</p>
        <ul>
            <li><strong>Ограничения ресурсов сервера:</strong> Количество доступных процессорных ядер и объём оперативной памяти сервера ограничивают число одновременно работающих потоков. Слишком большое количество потоков может привести к снижению производительности, так как процессор будет тратить время на переключение между ними.</li>
            <li><strong>Конфигурация пула соединений БД:</strong> Пул соединений имеет заданный максимум, который ограничивает количество активных соединений с БД. Этот предел защищает БД от перегрузки, но также ограничивает максимальное количество потоков, которые могут работать одновременно.</li>
            <li><strong>Настройки операционной системы:</strong> Операционная система имеет лимиты на количество файловых дескрипторов, которые можно открыть одновременно, а каждое подключение к БД может использовать один или несколько дескрипторов.</li>
            <li><strong>Конкурентный доступ к данным:</strong> С увеличением числа потоков могут возникнуть задержки из-за блокировок и транзакций, необходимых для обеспечения целостности данных, особенно при выполнении операций записи.</li>
        </ul>
        <h4>Пример:</h4>
        <p>Представьте себе систему интернет-банка, где несколько пользователей пытаются одновременно перевести деньги:</p>
        <ul>
            <li>Многопоточность позволяет каждому пользователю в своём потоке выполнять действия параллельно, создавая нагрузку на БД.</li>
            <li>Пул соединений распределяет запросы на подключение, чтобы уменьшить нагрузку и обеспечить доступ к БД для каждого потока.</li>
            <li>Блокировки и транзакции защищают от ситуаций, когда несколько пользователей пытаются изменить один и тот же счёт одновременно.</li>
        </ul>
  `,
    level: 'JUNIOR',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 13,
    question: 'Различия между реляционной и нереляционной БД? Статистика БД? Как посмотреть, что находится в конкретной таблице? Как писать условия для фильтрации? (WHERE)Как выбрать конкретные столбцы? Какте еще часто используемые команды есть?',
    answer: `
     <h3>База данных (БД) — это организованная коллекция данных, предназначенная для хранения, управления и обработки информации. Базы данных позволяют эффективно сохранять большие объёмы данных, легко находить нужные сведения и управлять ими. Базы данных могут быть реляционными и нереляционными.</h3>
      
      <ul>
        <li><strong>Реляционные базы данных (RDBMS):</strong> организуют данные в таблицы с четко определенной схемой (строки и столбцы). Они поддерживают сложные связи между таблицами с помощью первичных и внешних ключей. Реляционные базы данных используют язык SQL для работы с данными и отлично подходят для структурированных данных.</li>
        <p><strong>Примеры реляционных баз данных:</strong></p>
        <ul>
          <li><strong>MySQL:</strong> Открытая СУБД, широко используемая для веб-приложений и бизнес-систем.</li>
          <li><strong>PostgreSQL:</strong> Расширяемая и мощная база данных с поддержкой сложных операций и стандартов SQL.</li>
          <li><strong>Oracle:</strong> Коммерческая база данных с высокой производительностью, часто используемая для крупных корпоративных систем.</li>
          <li><strong>SQL Server:</strong> СУБД от Microsoft, используемая для бизнес-приложений и крупных систем управления данными.</li>
        </ul>

        <li><strong>Нереляционные базы данных (NoSQL):</strong> могут хранить данные в различных форматах — документы, графы, ключ-значение или столбцы. Эти базы данных не требуют строгой схемы и предназначены для работы с неструктурированными данными. Они хорошо масштабируются и оптимизированы для быстрого доступа к большим объемам данных.</li>
        <p><strong>Виды нереляционных баз данных и примеры:</strong></p>

        <ul>
          <li><strong>Документно-ориентированные базы данных:</strong> 
            <ul>
              <li><strong>MongoDB:</strong> Хранит данные в формате JSON-подобных документов, что делает её гибкой для хранения неструктурированных данных.</li>
              <li><strong>Couchbase:</strong> Документная база данных, поддерживающая модель "ключ-значение" и синхронизацию данных в реальном времени.</li>
            </ul>
          </li>
          
          <li><strong>Графовые базы данных:</strong>
            <ul>
              <li><strong>Neo4j:</strong> Использует графовую модель данных для представления и управления связями между данными, что делает её эффективной для работы с социальными сетями, рекомендациями и др.</li>
              <li><strong>Amazon Neptune:</strong> Полностью управляемая графовая база данных, оптимизированная для хранения и обработки сложных сетевых данных.</li>
            </ul>
          </li>

          <li><strong>Ключ-значение:</strong> 
            <ul>
              <li><strong>Redis:</strong> Высокоскоростная база данных типа "ключ-значение", часто используемая для кэширования данных и работы с сессиями.</li>
              <li><strong>Amazon DynamoDB:</strong> Быстро масштабируемая NoSQL база данных, использующая модель "ключ-значение" и предназначенная для высоконагруженных приложений.</li>
            </ul>
          </li>

          <li><strong>Сторожевые базы данных (Column-Family):</strong>
            <ul>
              <li><strong>Apache Cassandra:</strong> СУБД, оптимизированная для масштабируемых распределённых данных, основанных на модели "ключ-значение", но с хранением данных по столбцам.</li>
              <li><strong>HBase:</strong> Распределенная база данных, построенная на основе HDFS, которая поддерживает хранение больших данных по столбцам.</li>
            </ul>
          </li>
        </ul>
      </ul>

    <h3>Статистика БД</h3>
    <ul>
      <li><strong>Количество запросов:</strong> Общее количество SQL-запросов, обрабатываемых базой данных.</li>
      <li><strong>Время выполнения запросов:</strong> Показывает среднее, максимальное и минимальное время выполнения запросов.</li>
      <li><strong>Количество соединений:</strong> Количество активных соединений к базе данных.</li>
      <li><strong>Закэшированные данные:</strong> Статистика использования кэша для ускорения выполнения запросов.</li>
      <li><strong>Использование индексов:</strong> Статистика использования индексов для оптимизации запросов.</li>
      <li><strong>Количество блокировок:</strong> Блокировки строк или таблиц, замедляющие работу базы данных.</li>
    </ul>

    <h3>Для работы с данными в базе, мы используем SQL-запросы:</h3>
    <ul>
      <li><strong>Как посмотреть, что находится в конкретной таблице?</strong></li>
      <p>Для того чтобы увидеть все данные из таблицы, можно использовать команду <code>SELECT *</code>, где <code>*</code> означает выбор всех столбцов.</p>
      <pre><code>
        SELECT * FROM имя_таблицы;
      </code></pre>

      <li><strong>Как выбрать конкретные столбцы?</strong></li>
      <p>Чтобы выбрать только определённые столбцы, необходимо явно указать их в запросе:</p>
      <pre><code>
        SELECT столбец1, столбец2 FROM имя_таблицы;
      </code></pre>

      <li><strong>Как писать условия для фильтрации? (WHERE)</strong></li>
      <p>Для фильтрации данных в таблице используется условие <code>WHERE</code>. С его помощью можно указать условия для выбора строк, которые удовлетворяют определённым критериям:</p>
      <pre><code>
        SELECT * FROM имя_таблицы
        WHERE столбец = значение;
      </code></pre>
      <p>Также можно добавлять более сложные условия:</p>
      <pre><code>
        SELECT * FROM имя_таблицы
        WHERE столбец1 = значение1 AND столбец2 > значение2;
      </code></pre>
      <p>Другие операторы для фильтрации включают <code>LIKE</code> (поиск по шаблону), <code>IN</code> (выбор из множества значений), <code>BETWEEN</code> (диапазоны), и многие другие.</p>

      <li><strong>INSERT</strong> — добавляет новые записи в таблицу:</li>
      <pre><code>
        INSERT INTO имя_таблицы (столбец1, столбец2) VALUES (значение1, значение2);  -- Добавляет новую запись
      </code></pre>

      <li><strong>WHERE</strong> — используется для фильтрации строк в запросах:</li>
      <pre><code>
        SELECT * FROM имя_таблицы WHERE столбец = значение;  -- Условие для фильтрации данных
        SELECT * FROM имя_таблицы WHERE столбец1 = значение1 AND столбец2 > значение2;  -- Усложнённая фильтрация
      </code></pre>

      <li><strong>JOIN</strong> — объединяет данные из нескольких таблиц на основе общих значений в связанных столбцах:</li>
      <pre><code>
        SELECT t1.столбец1, t2.столбец2 
        FROM таблица1 t1
        JOIN таблица2 t2 ON t1.ключ = t2.ключ;  -- Пример объединения двух таблиц
      </code></pre>

      <li><strong>INNER JOIN</strong> — возвращает строки, которые имеют совпадение в обеих таблицах:</li>
      <pre><code>
        SELECT employees.first_name, departments.department_name
        FROM employees
        INNER JOIN departments ON employees.department_id = departments.id;  -- Возвращает только совпадения
      </code></pre>

      <li><strong>LEFT JOIN</strong> — возвращает все строки из левой таблицы и совпадающие строки из правой таблицы. Если совпадений нет, правые значения будут NULL:</li>
      <pre><code>
        SELECT t1.столбец1, t2.столбец2
        FROM таблица1 t1
        LEFT JOIN таблица2 t2 ON t1.ключ = t2.ключ;
      </code></pre>

      <li><strong>GROUP BY</strong> — группирует строки с одинаковыми значениями в указанных столбцах и позволяет применять агрегатные функции:</li>
      <pre><code>
        SELECT столбец, COUNT(*) 
        FROM имя_таблицы 
        GROUP BY столбец;  -- Группировка по значению в столбце
      </code></pre>

      <li><strong>HAVING</strong> — используется для фильтрации результатов после группировки:</li>
      <pre><code>
        SELECT столбец, COUNT(*) 
        FROM имя_таблицы 
        GROUP BY столбец 
        HAVING COUNT(*) > 5;  -- Фильтрация после группировки
      </code></pre>

      <li><strong>ORDER BY</strong> — сортирует результаты запроса по возрастанию или убыванию:</li>
      <pre><code>
        SELECT * FROM имя_таблицы ORDER BY столбец1 ASC, столбец2 DESC;  -- Сортировка данных по возрастанию и убыванию
      </code></pre>

      <li><strong>LIMIT</strong> — ограничивает количество возвращаемых строк в запросе:</li>
      <pre><code>
        SELECT * FROM имя_таблицы LIMIT 10;  -- Возвращает только первые 10 строк
      </code></pre>

      <li><strong>UNION</strong> — объединяет результаты двух запросов в одну таблицу, исключая дубликаты:</li>
      <pre><code>
        SELECT столбец1, столбец2 FROM таблица1 
        UNION 
        SELECT столбец1, столбец2 FROM таблица2;  -- Объединяет данные из двух таблиц
      </code></pre>

      <li><strong>Индексы (INDEX)</strong> — используются для ускорения поиска данных в таблице:</li>
      <pre><code>
        CREATE INDEX индекс_имя ON таблица(столбец);  -- Создание индекса для ускорения поиска по столбцу
        EXPLAIN SELECT * FROM таблица WHERE столбец = значение;  -- Используется для анализа, применяются ли индексы
      </code></pre>
      </ul>
      <ul>

    </ul>
        `,
    level: 'INTERN',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 14,
    question: 'Что такое HTTP протокол? Что такое Request? Что такое Response? Что такое Headers? Что такое Cookie? Что такое Body? Что такое Method? Коды состояния и текст статуса',
    answer: `
          <p><strong>HTTP (HyperText Transfer Protocol)</strong> — это протокол прикладного уровня, который используется для передачи данных в интернете. Он обеспечивает взаимодействие между клиентом (например, браузером) и сервером, работая по принципу "запрос-ответ". Этот протокол передаёт данные, такие как текст, изображения, видео и другие форматы, используя протоколы TCP/IP для доставки.</p>
          
          <h4>Как работает HTTP:</h4>
          <ol>
            <li><strong>Запрос клиента:</strong> Когда пользователь вводит URL в браузере или нажимает на ссылку, браузер отправляет HTTP-запрос на сервер. Запрос состоит из:
              <ul>
                <li>Метода (например, GET для получения данных или POST для отправки),</li>
                <li>URI (адреса ресурса, который запрашивается),</li>
                <li>Версии HTTP (например, HTTP/1.1 или HTTP/2),</li>
                <li>Дополнительных заголовков (например, типы данных, которые браузер может принять).</li>
              </ul>
            </li>
            <li><strong>Роль DNS:</strong> Прежде чем отправить запрос, браузер обращается к DNS (Domain Name System), чтобы преобразовать URL (например, www.example.com) в IP-адрес сервера.</li>
            <li><strong>Обработка на сервере:</strong> После получения запроса сервер обрабатывает его и возвращает HTTP-ответ, который состоит из:
              <ul>
                <li>Статуса ответа (например, 200 OK означает успешное выполнение),</li>
                <li>Заголовков (например, Content-Type — тип возвращаемого содержимого, и Content-Length — его размер),</li>
                <li>Тела ответа, которое может содержать запрашиваемую HTML-страницу или другой ресурс.</li>
              </ul>
            </li>
            <li><strong>Ответ сервера:</strong> Сервер отправляет данные обратно клиенту через тот же протокол TCP/IP. Браузер принимает данные и отображает их пользователю.</li>
          </ol>
          
          <h4>Безопасность в HTTP:</h4>
          <p>HTTPS — это защищённая версия HTTP, которая использует шифрование данных с помощью протоколов TLS (Transport Layer Security). Это необходимо для безопасной передачи данных, таких как пароли или информация о банковских картах. В отличие от HTTP, в HTTPS данные перед отправкой шифруются, что защищает их от перехвата.</p>
          
          <h4>Пример использования:</h4>
          <p>Когда вы вводите URL в браузере, например, https://www.example.com, браузер отправляет HTTPS-запрос на сервер, где данные шифруются и защищаются от несанкционированного доступа, а сервер возвращает зашифрованный ответ с запрашиваемыми данными.</p>
          
          <p>Таким образом, HTTP — это основа веб-связи, которая работает на уровне запросов и ответов, а HTTPS обеспечивает безопасность передачи данных в интернете.</p>
          
          <h4>Что такое Request?</h4>
    <p><strong>Request (Запрос)</strong> — это сообщение от клиента к серверу для получения данных или выполнения операций. Он включает метод (например, GET или POST), URL-адрес, заголовки и, возможно, тело (в зависимости от типа запроса).</p>
    
    <h4>Что такое Response?</h4>
    <p><strong>Response (Ответ)</strong> — это сообщение, которое сервер отправляет в ответ на запрос клиента. Оно содержит статус выполнения запроса (например, 200 OK), заголовки и тело ответа, которое может содержать запрашиваемые данные.</p>
    
    <h4>Что такое Headers?</h4>
    <p><strong>Headers (Заголовки)</strong> — это метаинформация, передаваемая в запросах и ответах HTTP. Они содержат информацию о типе контента, статусе запроса, разрешённых методах и другую служебную информацию. Например, заголовок Content-Type указывает тип передаваемого контента, а Accept говорит серверу, какой тип данных клиент ожидает получить.</p>
    
    <h4>Что такое Cookie?</h4>
    <p><strong>Cookie</strong> — это небольшие данные, которые сервер отправляет клиенту для хранения информации о сессиях, пользовательских настройках или других параметрах. При последующих запросах браузер автоматически отправляет эти cookie обратно серверу, что позволяет, например, сохранять авторизацию или пользовательские предпочтения.</p>
    
    <h4>Что такое Body?</h4>
    <p><strong>Body (Тело)</strong> — это основное содержимое HTTP-запроса или ответа, которое передаёт данные. В запросах оно используется, например, для отправки данных формы (POST-запрос), а в ответах может содержать HTML, JSON, XML или другие данные, которые сервер отправляет клиенту.</p>
    
    <h4>Что такое Method?</h4>
    <p><strong>Методы HTTP</strong> указывают, какое действие нужно выполнить на сервере:</p>
    <ul>
      <li><strong>GET:</strong> Получить данные с сервера.</li>
      <li><strong>POST:</strong> Отправить данные на сервер.</li>
      <li><strong>PUT:</strong> Обновить или создать ресурс на сервере.</li>
      <li><strong>DELETE:</strong> Удалить ресурс на сервере.</li>
      <li><strong>PATCH:</strong> Частичное обновление ресурса.</li>
    </ul>
    
    <h4>Коды состояния и текст статуса</h4>
    <p>Коды состояния показывают результат выполнения запроса:</p>
    <ul>
      <li><strong>200 OK:</strong> Запрос успешно выполнен.</li>
      <li><strong>201 Created:</strong> Запрос выполнен успешно, создан новый ресурс.</li>
      <li><strong>404 Not Found:</strong> Ресурс не найден.</li>
      <li><strong>500 Internal Server Error:</strong> На сервере произошла ошибка.</li>
    </ul>
        `,
    level: 'INTERN',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 15,
    question: "На примере своего проекта расскажи об архитектуре и с чем работает?",
    answer: `
      <p>Архитектура моего проекта включает в себя следующие компоненты:</p>
      <ul>
        <li><strong>Администратор Фин Портала:</strong> Работает с админкой финансового портала.</li>
        <li><strong>Admin Frontend (Frontend: React):</strong> Фронтенд админки для взаимодействия с системой администраторами. Взаимодействует с:</li>
        <ul>
          <li><strong>Admin Backend (Node.js):</strong> Обрабатывает административные задачи через API запросы (GraphQL, JSON).</li>
          <li><strong>FP Backend (Node.js):</strong> Отвечает за создание карточек инициатив и управление финансовыми показателями, взаимодействует с:</li>
          <ul>
            <li><strong>X5 Key (HTTP):</strong> Система авторизации для пользователей.</li>
            <li><strong>File Export Service (Node.js):</strong> Сервис рендеринга шаблонов документов (например, Word). Сохраненные документы отправляются в <strong>S3</strong> для хранения.</li>
            <li><strong>Database (PostgreSQL):</strong> Сохранение инициатив и финансовых показателей.</li>
            <li><strong>Gantt Converter API (Node.js):</strong> Сервис для построения диаграмм Ганта и рендеринга изображений, взаимодействует с <strong>MPP Converter API (Python)</strong> для конвертации файлов Microsoft Project.</li>
            <li><strong>Camunda API (Node.js):</strong> Управляет состоянием задач и взаимодействует с <strong>Camunda (BPM-engine: Java)</strong> для управления процессами.</li>
          </ul>
        </ul>
        <li><strong>Teamplanner (Application System):</strong> Система для планирования ресурсов, взаимодействует с Gravitee для создания и управления проектами.</li>
      </ul>
      <p>Таким образом, проект включает в себя множество сервисов, взаимодействующих через HTTP, TCP, и GraphQL запросы с использованием баз данных, файловых хранилищ и внешних API.</p>
    `,
    level: 'INTERN',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 47,
    question: 'Что такое Kubernetes и основные элементы?',
    answer: `
        <p>Kubernetes (или K8S) — это платформа с открытым исходным кодом для автоматического развертывания, управления и масштабирования контейнеризированных приложений. Она упрощает управление микросервисами и их взаимодействие.</p>

        <h3>Основные компоненты Kubernetes:</h3>
        <ul>
            <li><strong>Кластер:</strong> Это группа серверов (узлов), объединенных для работы приложений. Включает <em>Master Node</em> (управляющий узел) и <em>Worker Nodes</em> (рабочие узлы).</li>

            <li><strong>Узлы:</strong> Узел — это сервер (физический или виртуальный), на котором запускаются контейнеры. Каждый узел содержит агент Kubernetes (Kubelet) и среду для контейнеров, например Docker.</li>

            <li><strong>Плоскость управления (Control Plane):</strong> Управляет кластером и распределяет задачи:
                <ul>
                    <li><strong>Kubernetes API Server:</strong> Основной интерфейс для управления кластером через команды и запросы.</li>
                    <li><strong>etcd:</strong> Хранилище данных, где Kubernetes сохраняет всю информацию о кластере.</li>
                    <li><strong>Контроллеры:</strong> Обеспечивают нужное количество работающих контейнеров.</li>
                    <li><strong>Планировщик (Scheduler):</strong> Назначает контейнеры на узлы, оптимально распределяя их по серверу.</li>
                </ul>
            </li>

            <li><strong>Pod (Поды):</strong> Основная единица Kubernetes, представляющая контейнер или группу контейнеров, которые делят ресурсы (сеть, хранилище).</li>

            <li><strong>ReplicaSet:</strong> Гарантирует, что заданное количество подов будет всегда работать, поддерживая масштабирование подов.</li>

            <li><strong>Deployment:</strong> Управляет обновлениями и откатами подов, автоматически восстанавливает их в случае ошибок.</li>

            <li><strong>Service:</strong> Определяет, как можно получить доступ к подам, обеспечивает постоянный IP для группы подов.</li>

            <li><strong>Kubelet:</strong> Агент на каждом узле, который запускает и поддерживает контейнеры.</li>

            <li><strong>Kube-proxy:</strong> Сетевой компонент, управляет трафиком между подами и балансирует нагрузку внутри кластера.</li>
        </ul>

      <h3>Основные функции Kubernetes:</h3>
      <ul>
        <li>Масштабирование приложений в зависимости от нагрузки.</li>
        <li>Автоматическое восстановление подов в случае их падения.</li>
        <li>Балансировка нагрузки между узлами и репликами подов.</li>
        <li>Автоматизация развертываний и откатов обновлений.</li>
        <li>Мониторинг состояния приложений.</li>
        <li>Декларативное управление конфигурацией через манифесты (YAML файлы).</li>
      </ul>

      <h3>Основные команды kubectl:</h3>
      <ul>
        <li><strong>kubectl get pods</strong> — показывает список всех подов в кластере или в указанном namespace.</li>
        <li><strong>kubectl apply -f [файл]</strong> — применяет манифест для развертывания ресурсов (поды, сервисы и др.).</li>
        <li><strong>kubectl describe pod [имя]</strong> — выводит детальную информацию о поде.</li>
        <li><strong>kubectl logs [имя-пода]</strong> — показывает логи контейнера в поде.</li>
        <li><strong>kubectl scale --replicas=N deployment [имя]</strong> — изменяет количество реплик подов в deployment.</li>
      </ul>

      <h3>Гибкость и преимущества:</h3>
      <ul>
        <li>Автоматическое масштабирование приложений при увеличении нагрузки.</li>
        <li>Управление конфигурацией с помощью YAML манифестов.</li>
        <li>Поддержка откатов и обновлений без прерывания работы сервиса.</li>
        <li>Миграция приложений между различными облачными провайдерами благодаря независимости от инфраструктуры.</li>
      </ul>

      <h3>Когда использовать Kubernetes:</h3>
      <p>Kubernetes особенно полезен для компаний, использующих микросервисную архитектуру, где важно быстрое развертывание и масштабирование отдельных сервисов. Однако, для небольших монолитных приложений он может быть избыточен.</p>
      `,
    level: 'JUNIOR',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 99,
    question: 'Перечень основных тестов нагрузочного тестирования и их цели',
    answer: `
      <p><strong>Основные тесты:</strong> </p>
          <ul>
            <li><strong>Тест на поиск максимальной нагрузки:</strong> Определение предела, при котором система перестает справляться с запросами. </li>
            <li><strong>Тест стабильности:</strong> Проверка работы системы при постоянной нагрузке в течение длительного времени (например, 10 часов). Цель — выявить проблемы с утечкой памяти и нестабильностью работы.</li>
        <p><strong>Дополнительные тесты:</strong> </p>
            <li><strong>Стрессовое тестирование:</strong> Тестирование системы при экстремальных условиях, когда ее ресурсы могут быть исчерпаны. Основная цель — проверка устойчивости системы при экстремальных условиях.</li>
            <li><strong>Тестирование отказоустойчивости:</strong> Оценка способности системы сохранять работоспособность в условиях неблагоприятных факторов, таких как сбои в сети и отключение серверов.</li>
          </ul>
        `,
    level: 'INTERN',
    category: 'load',
    title: 'Perfomance engineer',
  },
 
  
  {
    id: 155,
    question: 'Статистика базы данных',
    answer: `
          <ul>
            <li><strong>Количество запросов:</strong> Общее количество SQL-запросов, обрабатываемых базой данных.</li>
            <li><strong>Время выполнения запросов:</strong> Показывает среднее, максимальное и минимальное время выполнения запросов.</li>
            <li><strong>Количество соединений:</strong> Количество активных соединений к базе данных.</li>
            <li><strong>Закэшированные данные:</strong> Статистика использования кэша для ускорения выполнения запросов.</li>
            <li><strong>Использование индексов:</strong> Статистика использования индексов для оптимизации запросов.</li>
            <li><strong>Количество блокировок:</strong> Блокировки строк или таблиц, замедляющие работу базы данных.</li>
          </ul>
        `,
    level: 'INTERN',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 177,
    question: 'Как снять heap dump и thread dump?',
    answer: `
        <p><strong>1. Heap Dump:</strong> Используйте команду <code>jmap</code> для создания heap dump:</p>
        <pre><code>jmap -dump:live,format=b,file=heapdump.hprof &lt;pid&gt;</code></pre>
        <p><strong>2. Thread Dump:</strong> Используйте команду <code>jstack</code> для получения состояния потоков:</p>
        <pre><code>jstack -l &lt;pid&gt; > threaddump.txt</code></pre>
      `,
    level: 'MIDDLE',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 26,
    question: 'Простые циклы с условиями на Python и Java',
    answer: `
          <p><strong>Цикл с условием while (Python):</strong></p>
          <pre><code>i = 0\nwhile i < 5:\n    if i % 2 == 0:\n        print(f"{i} is even")\n    else:\n        print(f"{i} is odd")\n    i += 1</code></pre>
          
          <p><strong>Цикл с условием while (Java):</strong></p>
          <pre><code>int i = 0;\nwhile (i < 5) {\n    if (i % 2 == 0) {\n        System.out.println(i + " is even");\n    } else {\n        System.out.println(i + " is odd");\n    }\n    i++;\n}</code></pre>
        `,
    level: 'INTERN',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 27,
    question: 'Реализация простейших алгоритмов на Python и Java',
    answer: `
          <p><strong>Алгоритм нахождения максимума в списке (Python):</strong></p>
          <pre><code>def find_max(arr):\n    max_value = arr[0]\n    for num in arr:\n        if num > max_value:\n            max_value = num\n    return max_value\n\nnumbers = [3, 5, 1, 9, 2]\nprint(find_max(numbers))  # Вывод: 9</code></pre>
          
          <p><strong>Алгоритм нахождения максимума в массиве (Java):</strong></p>
          <pre><code>public class Main {\n    public static int findMax(int[] arr) {\n        int maxValue = arr[0];\n        for (int num : arr) {\n            if (num > maxValue) {\n                maxValue = num;\n            }\n        }\n        return maxValue;\n    }\n\n    public static void main(String[] args) {\n        int[] numbers = {3, 5, 1, 9, 2};\n        System.out.println(findMax(numbers));  // Вывод: 9\n    }\n}</code></pre>
        `,
    level: 'INTERN',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 28,
    question: 'Функции работы с массивами на Python и Java',
    answer: `
          <p><strong>Обращение массива (Python):</strong></p>
          <pre><code>arr = [1, 2, 3, 4, 5]\nreversed_arr = arr[::-1]  # Метод срезов\nprint(reversed_arr)  # Вывод: [5, 4, 3, 2, 1]</code></pre>
          
          <p><strong>Обращение массива (Java):</strong></p>
          <pre><code>public class Main {\n    public static void reverseArray(int[] arr) {\n        for (int i = 0; i < arr.length / 2; i++) {\n            int temp = arr[i];\n            arr[i] = arr[arr.length - 1 - i];\n            arr[arr.length - 1 - i] = temp;\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, 4, 5};\n        reverseArray(arr);\n        for (int num : arr) {\n            System.out.print(num + " ");  // Вывод: 5 4 3 2 1\n        }\n    }\n}</code></pre>
        `,
    level: 'INTERN',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 29,
    question:
      'Как правильно использовать функции корреляции, проверок и границ транзакций в JMeter или другом инструменте нагрузочного тестирования?',
    answer: `
          <p><strong>JMeter:</strong></p>
          <ul>
            <li><strong>Корреляция:</strong> Это процесс захвата динамических данных из ответов сервера и их использования в последующих запросах.</li>
            <li>Пример в JMeter:</li>
            <pre><code>
              В JMeter используется Regular Expression Extractor для извлечения нужных данных. 
              Пример: после успешного входа в систему может быть возвращен уникальный токен сессии. Этот токен нужно захватить и передать в каждом последующем запросе для аутентификации.
            </code></pre>
            <li><strong>Проверки (Assertions):</strong> Позволяют убедиться, что система работает правильно, используя Response Assertion для проверки текста ответа или статус-кодов.</li>
            <li><strong>Границы транзакций (Transaction Controller):</strong> Измеряет время выполнения определённой группы запросов как одну транзакцию.</li>
          </ul>
    
          <p><strong>Locust:</strong></p>
          <ul>
            <li><strong>Корреляция:</strong> Выполняется вручную через парсинг ответов, используя библиотеки Python.</li>
            <pre><code>
              from locust import HttpUser, task
              
              class MyUser(HttpUser):
                  @task
                  def my_task(self):
                      response = self.client.get("/login")
                      token = response.json()["token"]
                      self.client.post("/submit", json={"token": token})
            </code></pre>
            <li><strong>Проверки:</strong> В Locust делаются вручную, как в обычном Python-коде.</li>
            <pre><code>
              class MyUser(HttpUser):
                  @task
                  def my_task(self):
                      response = self.client.get("/api/data")
                      assert response.status_code == 200, "Неправильный статус-код"
                      assert "expected_value" in response.text, "Ожидаемое значение не найдено"
            </code></pre>
            <li><strong>Границы транзакций:</strong> Используйте таймеры для измерения времени выполнения задач.</li>
            <pre><code>
              import time
              from locust import HttpUser, task
    
              class MyUser(HttpUser):
                  @task
                  def my_task(self):
                      start_time = time.time()
                      self.client.get("/api/data")
                      end_time = time.time()
                      elapsed_time = end_time - start_time
                      print(f"Время выполнения транзакции: {elapsed_time} секунд")
            </code></pre>
          </ul>
    
          <p><strong>Gatling:</strong></p>
          <ul>
            <li><strong>Корреляция:</strong> Динамические значения можно извлекать с помощью встроенных методов, таких как <code>check</code> и <code>saveAs</code>.</li>
            <li><strong>Проверки:</strong> Используются <code>Checks</code>, например, для проверки кода ответа.</li>
            <li><strong>Границы транзакций:</strong> Транзакции автоматически измеряются, но можно добавить тайминги с помощью <code>exec().startTimer().stopTimer()</code>.</li>
          </ul>
        `,
    level: 'JUNIOR',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 36,
    question: 'Какой есть предел потоков у приложения?',
    answer: `
          <p>Предел количества потоков у приложения зависит от нескольких факторов, включая ресурсы системы и настройки операционной системы. Хотя теоретически можно создать очень много потоков, на практике существуют ограничения, которые зависят от следующих аспектов:</p>
          <ol>
            <li><strong>Ограничения операционной системы:</strong>
              <ul>
                <li>Операционная система устанавливает ограничения на количество потоков, которые можно запустить в одном процессе. Это ограничение зависит от архитектуры системы, настройки ядра, доступных ресурсов (памяти, CPU).</li>
                <li>В системах Linux и Windows есть параметры, которые можно настроить для увеличения или уменьшения количества допустимых потоков.</li>
              </ul>
            </li>
            <li><strong>Память:</strong>
              <ul>
                <li>Каждый поток требует выделения памяти для своего стека (обычно от 256 КБ до 1 МБ на поток). Чем больше потоков, тем больше оперативной памяти требуется для их поддержания.</li>
                <li>Если количество потоков превышает возможности системы по памяти, это приведет к OutOfMemoryError или другим ошибкам, связанным с нехваткой ресурсов.</li>
              </ul>
            </li>
            <li><strong>Ресурсы процессора (CPU):</strong>
              <ul>
                <li>Количество ядер процессора влияет на эффективность многопоточных приложений. Большое количество потоков может приводить к "контекстным переключениям", когда процессор переключается между потоками, что снижает производительность. Хотя можно создать много потоков, они не будут одновременно выполняться, если не хватает физических или логических ядер.</li>
              </ul>
            </li>
            <li><strong>Конфигурации JVM (для Java-приложений):</strong>
              <ul>
                <li>В Java приложениям можно задать предел количества потоков через параметры JVM, такие как -Xss (размер стека для потока). Например, уменьшив размер стека потока, можно создать больше потоков, но это приведет к меньшему количеству доступной памяти для каждого потока.</li>
              </ul>
            </li>
          </ol>
          <h4>Пример практических ограничений:</h4>
          <ul>
            <li><strong>В 32-битных системах:</strong> Ограничение на количество потоков может быть около 1000-2000, так как 32-битная система имеет ограниченный объём памяти.</li>
            <li><strong>В 64-битных системах:</strong> Количество потоков может быть значительно больше (десятки тысяч), так как 64-битная система поддерживает больше памяти.</li>
          </ul>
        `,
    level: 'JUNIOR',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 37,
    question:
      'Чем отличается виртуальный пользователь(Thread) от потока внутри приложения?',
    answer: `
          <p><strong>Виртуальный пользователь (Thread)</strong> в нагрузочном тестировании и поток внутри приложения — это два разных понятия, хотя и имеют похожие принципы работы.</p>
          <h4>1. Виртуальный пользователь (Thread) в нагрузочном тестировании:</h4>
          <ul>
            <li><strong>Определение:</strong> Виртуальный пользователь (VU, виртуальный поток) в таких инструментах, как JMeter или Locust, — это эмуляция действий одного пользователя, который взаимодействует с системой. Он имитирует реальных пользователей, отправляя запросы на сервер для тестирования его производительности.</li>
            <li><strong>Назначение:</strong> Основная задача виртуальных пользователей — создать нагрузку на систему, чтобы оценить её поведение под различной интенсивностью запросов (например, при 100, 1000 или 10 000 пользователей).</li>
            <li><strong>Особенности:</strong>
              <ul>
                <li>Виртуальные пользователи могут запускаться параллельно, но не обязательно напрямую связаны с многопоточностью внутри приложения.</li>
                <li>Каждый виртуальный пользователь может выполнять сценарий теста, который включает последовательность действий (например, логин, запрос данных, выход).</li>
                <li>В JMeter или Locust виртуальные пользователи настраиваются через Thread Group, которая указывает, сколько "пользователей" будет одновременно выполнять тестовые сценарии.</li>
              </ul>
            </li>
          </ul>
          <h4>2. Поток внутри приложения:</h4>
          <ul>
            <li><strong>Определение:</strong> Поток (thread) в контексте многопоточности приложения — это "параллельная" единица выполнения, которая работает в одном процессе. Потоки внутри приложения делят общую память и ресурсы между собой и могут выполнять различные задачи одновременно.</li>
            <li><strong>Назначение:</strong> Потоки в приложении используются для повышения производительности и эффективности. Например, один поток может обрабатывать пользовательский ввод, другой — выполнять вычисления, третий — ждать ответа от сервера.</li>
            <li><strong>Особенности:</strong>
              <ul>
                <li>Потоки внутри приложения делят между собой общие ресурсы, такие как память, что требует тщательной синхронизации, чтобы избежать конфликтов.</li>
                <li>Потоки используют процессорные ресурсы и могут выполнять задачи параллельно, если система поддерживает многопоточность.</li>
                <li>Управление потоками осуществляется через код приложения, и их выполнение может быть более сложным, так как нужно учитывать синхронизацию и управление доступом к общим ресурсам.</li>
              </ul>
            </li>
          </ul>
          <h4>Основные отличия:</h4>
          <table>
            <thead>
              <tr>
                <th>Критерий</th>
                <th>Виртуальный пользователь (Thread в нагрузочном тестировании)</th>
                <th>Поток внутри приложения (Thread)</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Назначение</td>
                <td>Имитация действий реальных пользователей для тестирования нагрузки на систему</td>
                <td>Выполнение нескольких задач одновременно внутри одного процесса</td>
              </tr>
              <tr>
                <td>Контекст работы</td>
                <td>Работает как независимая сущность, выполняя сценарий теста, взаимодействуя с сервером</td>
                <td>Выполняет задачи в рамках одного процесса, может делить память и ресурсы с другими потоками</td>
              </tr>
              <tr>
                <td>Взаимодействие с системой</td>
                <td>Отправляет HTTP-запросы или выполняет другие действия для создания нагрузки</td>
                <td>Выполняет вычисления, операции ввода-вывода, обработку данных и др. внутри программы</td>
              </tr>
              <tr>
                <td>Управление</td>
                <td>Настраивается через инструменты тестирования (например, JMeter, Locust)</td>
                <td>Управляется разработчиками через код приложения</td>
              </tr>
              <tr>
                <td>Ресурсы</td>
                <td>Использует ресурсы тестирующего инструмента и создаёт нагрузку на сервер</td>
                <td>Использует процессорные ресурсы и память приложения, требуя синхронизации</td>
              </tr>
            </tbody>
          </table>
          <h4>Пример:</h4>
          <ul>
            <li><strong>Виртуальный пользователь:</strong> В JMeter может отправлять HTTP-запросы, имитируя поведение пользователя, заходящего на веб-сайт, отправляя запросы и получая ответы.</li>
            <li><strong>Поток внутри приложения:</strong> В Java может одновременно обрабатывать запросы от нескольких пользователей, где один поток работает с базой данных, а другой отправляет данные обратно пользователю.</li>
          </ul>
          <p><strong>Заключение:</strong> Виртуальный пользователь в нагрузочном тестировании — это инструмент для имитации реальных пользователей, создающий нагрузку на систему. Поток внутри приложения — это механизм параллельного выполнения задач в одном процессе программы, который повышает производительность работы приложения.</p>
        `,
    level: 'JUNIOR',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 38,
    question:
      'Например, у нас залогинились 1000 виртуальных пользователей одновременно, сколько будет потоков?',
    answer: `
          <p>Если у вас 1000 виртуальных пользователей в JMeter, это создаст 1000 потоков в самом JMeter, каждый из которых будет выполнять свои действия параллельно (например, логин).</p>
          <p>Однако на сервере количество потоков будет зависеть от его настроек. Сервер может использовать пул потоков (например, 200 потоков), и обрабатывать запросы по очереди, а не все одновременно.</p>
          <p>То есть:</p>
          <ul>
            <li>1000 виртуальных пользователей в JMeter = 1000 потоков в JMeter.</li>
            <li>Сервер может иметь меньше потоков, в зависимости от своей конфигурации.</li>
          </ul>
        `,
    level: 'JUNIOR',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 39,
    question: 'Пул коннектов это?',
    answer: `
          <p><strong>Пул коннектов</strong> — это механизм управления соединениями с базой данных или другим ресурсом, который позволяет многократно использовать созданные соединения. Вместо того чтобы каждый раз создавать и закрывать соединение, пул коннектов сохраняет несколько активных соединений, готовых к использованию, и предоставляет их по запросу.</p>
          <h4>Основные характеристики:</h4>
          <ul>
            <li><strong>Повторное использование:</strong> Соединения не создаются каждый раз заново, а берутся из пула.</li>
            <li><strong>Эффективность:</strong> Экономится время на создание и закрытие соединений, что улучшает производительность приложения.</li>
            <li><strong>Ограничение ресурсов:</strong> Пул управляет количеством одновременно активных соединений, чтобы не перегружать базу данных.</li>
          </ul>
          <h4>Пример:</h4>
          <p>Приложение может создать пул из 10 коннектов. Когда пользователю нужно соединение с базой данных, оно берётся из пула. После завершения работы соединение возвращается в пул для повторного использования другими пользователями.</p>
        `,
    level: 'JUNIOR',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 40,
    question: 'Что такое уровни логирования?',
    answer: `
          <ul>
            <li><strong>TRACE:</strong> Самый детализированный уровень.</li>
            <li><strong>DEBUG:</strong> Отладочная информация.</li>
            <li><strong>INFO:</strong> Общая информация о работе приложения.</li>
            <li><strong>WARN:</strong> Предупреждения о возможных проблемах.</li>
            <li><strong>ERROR:</strong> Ошибки, которые требуют внимания.</li>
            <li><strong>FATAL:</strong> Критические ошибки, приводящие к завершению работы приложения.</li>
          </ul>
        `,
    level: 'JUNIOR',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 41,
    question: 'Что такое парсинг логов?',
    answer: `
         <p>
      Парсинг логов — это процесс автоматического анализа и обработки лог-файлов с целью извлечения полезной информации, такой как ошибки, предупреждения, статистика производительности, успешные или неуспешные операции. Лог-файлы обычно содержат информацию о работе системы, которая записывается в текстовые файлы. Парсинг помогает структурировать эти данные и использовать их для мониторинга, анализа и отладки.
    </p>
    <h4>Основные задачи парсинга логов:</h4>
    <ol>
      <li><strong>Поиск ошибок:</strong> Автоматическое извлечение и классификация ошибок, которые произошли в системе.</li>
      <li><strong>Мониторинг производительности:</strong> Сбор данных о времени отклика, загрузке системы и других метриках из логов.</li>
      <li><strong>Фильтрация данных:</strong> Удаление ненужной информации и извлечение только тех данных, которые важны для анализа.</li>
      <li><strong>Анализ событий:</strong> Определение последовательности событий и их влияние на производительность или стабильность системы.</li>
    </ol>
        `,
    level: 'JUNIOR',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 42,
    question: 'Простые запросы с помощью SELECT',
    answer: `
          <ul>
            <li>Получение всех строк из таблицы:</li>
            <pre><code>SELECT * FROM employees;</code></pre>
            <li>Получение конкретных столбцов:</li>
            <pre><code>SELECT first_name, last_name FROM employees;</code></pre>
            <li>Фильтрация с использованием WHERE:</li>
            <pre><code>SELECT * FROM employees WHERE age > 30;</code></pre>
          </ul>
        `,
    level: 'JUNIOR',
    category: 'load',
    title: 'Perfomance engineer',
  },
  // {
  //   id: 43,
  //   question: 'Использование функций JOIN, GROUP BY, HAVING',
  //   answer: `
  //         <ul>
  //           <li><strong>JOIN:</strong> Объединение данных из двух таблиц.</li>
  //           <pre><code>
  //             SELECT employees.first_name, departments.department_name
  //             FROM employees
  //             INNER JOIN departments ON employees.department_id = departments.id;
  //           </code></pre>
  //           <li><strong>GROUP BY:</strong> Группировка строк по столбцам.</li>
  //           <pre><code>
  //             SELECT department_id, COUNT(*)
  //             FROM employees
  //             GROUP BY department_id;
  //           </code></pre>
  //           <li><strong>HAVING:</strong> Фильтрация результатов после группировки.</li>
  //           <pre><code>
  //             SELECT department_id, COUNT(*)
  //             FROM employees
  //             GROUP BY department_id
  //             HAVING COUNT(*) > 5;
  //           </code></pre>
  //         </ul>
  //       `,
  //   level: 'JUNIOR',
  //   category: 'load',
  //   title: 'Perfomance engineer',
  // },
  {
    id: 44,
    question: 'Что такое агрегирование функций?',
    answer: `
        <p>Агрегатные функции — это функции, которые применяются к группе строк и возвращают одно значение для каждой группы. Часто используются вместе с <code>GROUP BY</code>.</p>
        <ul>
          <li><strong>COUNT():</strong> Возвращает количество строк.</li>
          <pre><code>SELECT COUNT(*) FROM employees;</code></pre>
          <li><strong>SUM():</strong> Возвращает сумму значений в столбце.</li>
          <pre><code>SELECT SUM(salary) FROM employees;</code></pre>
          <li><strong>AVG():</strong> Возвращает среднее значение.</li>
          <pre><code>SELECT AVG(salary) FROM employees;</code></pre>
          <li><strong>MAX():</strong> Возвращает максимальное значение.</li>
          <pre><code>SELECT MAX(salary) FROM employees;</code></pre>
          <li><strong>MIN():</strong> Возвращает минимальное значение.</li>
          <pre><code>SELECT MIN(salary) FROM employees;</code></pre>
        </ul>
        <p>Пример объединения всех функций:</p>
        <pre><code>
          SELECT department_id, AVG(salary), MAX(salary), MIN(salary)
          FROM employees
          GROUP BY department_id
          HAVING AVG(salary) > 50000;
        </code></pre>
        <p>Этот запрос группирует сотрудников по отделам, вычисляет среднюю, максимальную и минимальную зарплату, и выводит только те отделы, где средняя зарплата больше 50 000.</p>
      `,
    level: 'JUNIOR',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 45,
    question: 'Что такое Spring Boot?',
    answer: `
        <p><strong>Spring Boot</strong> — это фреймворк для упрощенной разработки Java-приложений с использованием экосистемы Spring. Он предоставляет встроенные механизмы для быстрой настройки и запуска приложений, минимизируя конфигурацию.</p>
        <p>Основные особенности Spring Boot:</p>
        <ul>
          <li><strong>Автоконфигурация:</strong> Автоматически настраивает компоненты приложения на основе зависимостей.</li>
          <li><strong>Встроенные серверы:</strong> Включает встроенные серверы, такие как Tomcat и Jetty.</li>
          <li><strong>Поддержка микросервисов:</strong> Легко использовать для создания микросервисов.</li>
        </ul>
        <p>Пример простого Spring Boot приложения:</p>
        <pre><code class="language-java">
          import org.springframework.boot.SpringApplication;
          import org.springframework.boot.autoconfigure.SpringBootApplication;
          import org.springframework.web.bind.annotation.GetMapping;
          import org.springframework.web.bind.annotation.RestController;
  
          @SpringBootApplication
          public class MySpringBootApplication {
  
            public static void main(String[] args) {
              SpringApplication.run(MySpringBootApplication.class, args);
            }
  
            @RestController
            class MyController {
              @GetMapping("/hello")
              public String sayHello() {
                return "Hello, Spring Boot!";
              }
            }
          }
        </code></pre>
        <p>Этот код является простым примером Spring Boot приложения, которое запускает встроенный веб-сервер и предоставляет REST API с единственным HTTP-методом GET по пути <code>/hello</code>.</p>
      `,
    level: 'JUNIOR',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 46,
    question: 'Что такое Apache Kafka и основные принципы?',
    answer: `
        <p><strong>Apache Kafka</strong> — это распределённая платформа потоковой передачи сообщений, используемая для создания высокопроизводительных систем реального времени.</p>
        <p>Основные принципы работы Apache Kafka:</p>
        <ul>
          <li><strong>Тема (Topic):</strong> Логический канал для организации сообщений в Kafka.</li>
          <li><strong>Производитель (Producer):</strong> Отправляет сообщения в тему Kafka.</li>
          <li><strong>Потребитель (Consumer):</strong> Читает сообщения из темы Kafka.</li>
          <li><strong>Разделы (Partitions):</strong> Темы разделены на несколько частей для параллельной обработки.</li>
          <li><strong>Репликация и отказоустойчивость:</strong> Kafka поддерживает репликацию данных для повышения надёжности.</li>
        </ul>
      `,
    level: 'JUNIOR',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 49,
    question: 'Скрипт для сбора логов',
    answer: `
        <p>Пример скрипта на Python для сбора логов:</p>
        <pre><code class="language-python">
          import os
          import time
  
          log_file = "/path/to/logfile.log"
  
          def follow_log(file_path):
              with open(file_path, 'r') as f:
                  f.seek(0, os.SEEK_END)
                  while True:
                      line = f.readline()
                      if not line:
                          time.sleep(0.1)
                          continue
                      yield line
  
          def write_logs_to_file(log_lines, output_file):
              with open(output_file, 'a') as f:
                  for line in log_lines:
                      f.write(line)
  
          if __name__ == "__main__":
              log_lines = follow_log(log_file)
              output_log_file = "/path/to/output_logfile.log"
              write_logs_to_file(log_lines, output_log_file)
        </code></pre>
        <p>Пример на Java:</p>
        <pre><code class="language-java">
          import java.io.IOException;
          import java.nio.file.*;
  
          public class LogCollector {
  
              public static void main(String[] args) {
                  Path logFile = Paths.get("/path/to/logfile.log");
                  Path outputLogFile = Paths.get("/path/to/output_logfile.log");
  
                  try {
                      WatchService watchService = FileSystems.getDefault().newWatchService();
                      logFile.getParent().register(watchService, StandardWatchEventKinds.ENTRY_MODIFY);
  
                      while (true) {
                          WatchKey key = watchService.take();
                          for (WatchEvent<?> event : key.pollEvents()) {
                              if (event.context().toString().equals(logFile.getFileName().toString())) {
                                  Files.lines(logFile)
                                      .forEach(line -> {
                                          try {
                                              Files.write(outputLogFile, (line + "\\n").getBytes(), StandardOpenOption.APPEND);
                                          } catch (IOException e) {
                                              e.printStackTrace();
                                          }
                                      });
                              }
                          }
                          key.reset();
                      }
                  } catch (IOException | InterruptedException e) {
                      e.printStackTrace();
                  }
              }
          }
        </code></pre>
      `,
    level: 'MIDDLE',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 50,
    question:
      'Как анализировать систему по количеству потоков, пулов, коннектов, времени работы GC, heap и non-heap?',
    answer: `
        <p><strong>1. Количество потоков (Threads):</strong> Используйте <code>jconsole</code> или <code>jstack</code> для мониторинга потоков в JVM.</p>
        <p><strong>2. Пулы потоков (Thread Pools):</strong> Анализируйте пулы потоков, чтобы избежать перегрузки.</p>
        <p><strong>3. Пулы соединений (Connection Pools):</strong> Контролируйте количество соединений к БД (например, с HikariCP).</p>
        <p><strong>4. Время работы GC (Garbage Collection):</strong> Используйте <code>jstat</code> или <code>VisualVM</code> для мониторинга.</p>
        <p><strong>5. Heap и Non-Heap память:</strong> Анализируйте состояние heap и non-heap памяти с помощью <code>jconsole</code> или <code>VisualVM</code>.</p>
      `,
    level: 'MIDDLE',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 51,
    question: 'Как выявить долгие запросы в БД?',
    answer: `
        <p>Мониторинг медленных запросов можно выполнять с помощью системных таблиц или включения логов медленных запросов.</p>
        <p>Пример запроса для PostgreSQL:</p>
        <pre><code>
          SELECT pid, query, state, age(now(), query_start) AS duration
          FROM pg_stat_activity
          WHERE state = 'active'
          ORDER BY duration DESC;
        </code></pre>
      `,
    level: 'MIDDLE',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 53,
    question: 'INSERT и UPDATE в SQL',
    answer: `
        <p><strong>INSERT:</strong> Команда для добавления новых записей в таблицу:</p>
        <pre><code>
          INSERT INTO employees (first_name, last_name, age, department)
          VALUES ('John', 'Doe', 30, 'IT');
        </code></pre>
        <p><strong>UPDATE:</strong> Команда для обновления существующих записей:</p>
        <pre><code>
          UPDATE employees
          SET age = 31
          WHERE first_name = 'John' AND last_name = 'Doe';
        </code></pre>
      `,
    level: 'MIDDLE',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 54,
    question: 'Как массово обновить данные в БД?',
    answer: `
        <p>Массовое обновление данных в базе данных можно выполнить с помощью <code>UPDATE</code>:</p>
        <pre><code>
          UPDATE employees
          SET department = 'Sales'
          WHERE department = 'Marketing';
        </code></pre>
      `,
    level: 'MIDDLE',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 55,
    question:
      'Что такое индекс и как с ним работать? Как проверять индексы в БД?',
    answer: `
        <p><strong>Индекс</strong> — это структура данных для ускорения поиска и сортировки данных в таблице.</p>
        <p><strong>Преимущества индексов:</strong></p>
        <ul>
          <li>Улучшают производительность запросов на выборку (SELECT).</li>
        </ul>
        <p>Пример создания индекса:</p>
        <pre><code>
          CREATE INDEX idx_employee_name ON employees (first_name, last_name);
        </code></pre>
      `,
    level: 'MIDDLE',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 56,
    question: 'Что такое системные таблицы в БД?',
    answer: `
        <p>Системные таблицы — это таблицы, которые хранят метаинформацию о структуре базы данных и активных сессиях.</p>
        <p>Пример для PostgreSQL:</p>
        <pre><code>
          SELECT pid, usename, state, query
          FROM pg_stat_activity;
        </code></pre>
      `,
    level: 'MIDDLE',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 57,
    question: 'Балансировщики это?',
    answer:
      'Балансировщики нагрузки — это системы, распределяющие входящий трафик между несколькими серверами для обеспечения высокой доступности, повышения производительности и предотвращения перегрузки отдельных серверов.',
    level: 'INTERN',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 58,
    question: 'Распределенные кэши это?',
    answer:
      'Распределенные кэши — это системы, хранящие данные в нескольких узлах или серверах, что позволяет приложениям быстрее обращаться к данным и снижает нагрузку на базу данных.',
    level: 'INTERN',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 59,
    question: 'Чем контейнеры отличаются от виртуальных машин?',
    answer:
      'Контейнеры используют одно ядро операционной системы и изолируют приложения на уровне процессов, в то время как виртуальные машины (ВМ) имеют собственные операционные системы, что делает ВМ более тяжелыми и медленными. Контейнеры легче и быстрее развертываются.',
    level: 'INTERN',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 60,
    question: 'Как работают контейнеры в Docker и Kubernetes?',
    answer:
      'Docker — это платформа для создания, развертывания и управления контейнерами. Kubernetes управляет контейнерами Docker на кластере серверов, автоматизируя их развертывание, масштабирование и управление, поддерживая высокую доступность и распределение нагрузки.',
    level: 'INTERN',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 61,
    question: 'Чем характеризуется поиск максимума?',
    answer:
      'Поиск максимума характеризуется постепенным увеличением нагрузки на систему до достижения предельной производительности, после чего регистрируются сбои или падение производительности системы.',
    level: 'INTERN',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 62,
    question: 'От чего зависит длина ступени в тесте поиска максимума?',
    answer:
      'Длина ступени в тесте поиска максимума зависит от времени, необходимого для стабилизации системы после увеличения нагрузки, чтобы можно было точно зафиксировать реакцию системы на изменение нагрузки.',
    level: 'INTERN',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 63,
    question: 'От чего зависит длина теста надежности?',
    answer:
      'Длина теста надежности зависит от времени, необходимого для подтверждения того, что система стабильно работает при постоянной нагрузке. Это время определяется требованиями проекта и сценариями использования системы.',
    level: 'INTERN',
    category: 'load',
    title: 'Perfomance engineer',
  },
  {
    id: 64,
    question: 'Объемное тестирование это?',
    answer:
      'Объемное тестирование — это тип тестирования, при котором система проверяется на способность обрабатывать большие объемы данных или трафика, чтобы выявить пределы производительности при максимальной нагрузке.',
    level: 'INTERN',
    category: 'load',
    title: 'Perfomance engineer',
  },
];
