export const questions = [
    {
      id: 1,
      question: "Что такое НТ?",
      answer: `Нагрузочное тестирование (НТ) — это проверка устойчивости и производительности программного обеспечения под нагрузкой, сопоставимой с реальными условиями использования."
      <p>Источник: <a href="https://habr.com/ru/companies/otus/articles/842150/" target="_blank">https://habr.com/ru/companies/otus/articles/842150//</a></p>`,
      level: "INTERN"
    },
    {
      id: 2,
      question: "Что такое МНТ?",
      answer: `
      <p>Методика нагрузочного тестирования (МНТ) – согласованный с заказчиком документ, регламентирующий проводимые тесты, средства тестирования, профиль нагрузки, SLA (Service level agreement – соглашение о качестве предоставляемых услуг).</p>
      <ul>
        <li><strong>Объект тестирования:</strong> Описание системы и её функций.</li>
        <li><strong>Цели испытаний:</strong> Определение максимальной нагрузки, проверка требований, выявление узких мест.</li>
        <li><strong>Конфигурация оборудования:</strong> Описание ресурсов (CPU, память), используемых для тестирования на различных стендах.</li>
        <li><strong>Требования к производительности:</strong> Определение допустимых показателей (например, утилизация CPU и RAM, процент ошибок).</li>
        <li><strong>Сценарии нагрузочного тестирования:</strong> Ссылки на сценарии и описание запросов для выполнения тестов.</li>
        <li><strong>Профили нагрузки:</strong> Описание интенсивности запросов и задержек.</li>
        <li><strong>Список нагрузочных испытаний:</strong> Тесты на максимальную нагрузку, стабильность, с указанием ключевых метрик.</li>
        <li><strong>Средства нагрузочного тестирования:</strong> Инструменты для тестирования (Locust, Grafana, Prometheus) и генерация нагрузки.</li>
        <li><strong>Список метрик:</strong> Время отклика, успешность операций, пропускная способность системы.</li>
        <li><strong>Отчеты:</strong> Порядок формирования отчётов с результатами испытаний и сравнение с эталонными тестами.</li>
        <li><strong>Генерация:</strong> Процесс сбора и управления большим объемом данных из различных ресурсов только для реализации тестовых примеров для обеспечения функциональной надежности тестируемой системы.</li>
      </ul>
       <img :src="require('@/assets/img/mlt.png')" alt="MNT Image" style="width:100%; margin-top:20px;" />
    `,
    level: "INTERN"
    },
    {
      id: 2.1,
      question: "В МНТ есть раздел генерация БД, о чем он и зачем нужен?",
      answer: `
        Основные цели раздела "Генерация БД":
    
        1. Создание объёма данных:
          Для проведения нагрузочного тестирования требуется, чтобы база данных содержала значительное количество записей (например, пользователей, транзакций, продуктов). Это помогает симулировать реальную работу системы под высокой нагрузкой.
          Генерация данных позволяет протестировать работу системы с большими объёмами информации и убедиться, что она справляется с нагрузкой.
          
        2. Реалистичное тестирование:
          Данные, генерируемые для тестов, должны быть максимально приближены к реальным данным. Это позволит более точно оценить поведение системы в продакшене.
          Генерация данных может включать создание не только записей в таблицах, но и заполнение связей между таблицами, создание индексов и других элементов структуры базы данных.
        
        3. Сценарии тестирования:
          Некоторые сценарии нагрузочного тестирования могут предполагать выполнение операций с различными объёмами данных. Например, тестирование производительности поиска по базе данных или выполнения сложных SQL-запросов. Для таких тестов необходима база с различным количеством записей.
        
        4. Избежание дублирования:
          Генерация данных также может помочь избежать использования одних и тех же данных многими виртуальными пользователями, что сделает тестирование более приближённым к реальной эксплуатации.
    
        Зачем нужна генерация БД:
          - Тестирование на больших объёмах данных: Генерация БД позволяет протестировать систему с реальными объёмами данных, которые она будет обрабатывать в продакшене.
          - Подготовка данных для разных тестовых сценариев: Разные типы тестов могут требовать различных данных (например, для сценариев с чтением, записью, обновлением или удалением данных).
          - Оценка производительности базы данных: Нагрузка на базу данных и время отклика зависят от количества данных. Генерация данных позволяет создать условия, при которых можно оценить, как система будет работать под реальной нагрузкой.
          - Имитирование реальных условий: Генерация БД создаёт реальные или реалистичные данные, чтобы симулировать реальные сценарии использования.
    
        Таким образом, раздел "Генерация БД" является важной частью подготовки к нагрузочному тестированию, так как он обеспечивает наличие данных для полноценной проверки работы системы под нагрузкой.
      `,
      level: "INTERN"
    },
    {
        id: 3,
        question: "Что нужно прописывать в отчёте?",
        answer: `
          <ul>
            <li><strong>Объект тестирования:</strong> Описание системы, как в МНТ.</li>
            <li><strong>Цели испытаний:</strong> Конкретные задачи теста, например, выявление узких мест.</li>
            <li><strong>Конфигурация стендов:</strong> Параметры ресурсов (CPU, память, количество реплик).</li>
            <li><strong>Требования к производительности:</strong> Описание достигнутых результатов по утилизации ресурсов и процент ошибок.</li>
            <li><strong>Результаты тестов:</strong> Метрики по времени отклика, пропускной способности, количеству ошибок и успешных операций.</li>
            <li><strong>Анализ результатов:</strong> Сравнение с эталонными тестами (если применимо) и выявление проблем.</li>
            <li><strong>Отчеты по тестам:</strong> Ссылки на подробные отчёты и краткий анализ по итогам тестов.</li>
          </ul>
        `,
        level: "INTERN"
      },
      {
        id: 4,
        question: "Как записать простой скрипт с помощью Recording в JMeter?",
        answer: `
          <ul>
            <li><strong>Открой JMeter</strong> и добавь HTTP(S) Test Script Recorder.</li>
            <li><strong>Настрой прокси-сервер</strong> для захвата трафика (укажи порт).</li>
            <li><strong>Добавь Thread Group</strong> для организации сценария.</li>
            <li><strong>Запусти запись</strong> и проведи необходимые действия в браузере/приложении.</li>
            <li><strong>Останови запись</strong> — все запросы будут сохранены в виде шагов в сценарии.</li>
          </ul>
        `,
        level: "INTERN"
      },
      {
        id: 4.1,
        question: "Основные шаги настройки скрипта в JMeter после записи?",
        answer: `
          1. Очистка скрипта:
             - Удалите ненужные запросы (статические ресурсы: CSS, JS, изображения).
             - Группируйте запросы с помощью Transaction Controller для удобства и измерения времени выполнения транзакций.
      
          2. Параметризация:
             - Используйте CSV Data Set Config для замены статических данных (логины, пароли) на динамические переменные из файла.
             - Пример:
               POST /login
               {
                 "username": "\${username}",
                 "password": "\${password}"
               }
      
          3. Корреляция:
             - Извлекайте динамические данные (например, токены) с помощью Regular Expression Extractor или JSON Extractor.
             - Пример регулярного выражения: "sessionId":"(.+?)".
      
          4. Добавление тайм-аутов (Think Time):
             - Добавьте паузы между запросами с помощью Constant Timer или Uniform Random Timer для симуляции реального поведения пользователей.
      
          5. Настройка Thread Group:
             - Установите количество пользователей (Number of Threads), время разгона (Ramp-Up Period) и количество повторений сценария (Loop Count).
      
          6. Проверки (Assertions):
             - Добавьте Response Assertion для проверки кода ответа или содержания ответа, чтобы убедиться, что запросы успешны.
      
          7. Сбор метрик (Listeners):
             - Используйте Summary Report, View Results Tree для сбора метрик по времени отклика, проценту ошибок и другим параметрам.
      
          8. Мониторинг производительности:
             - Добавьте PerfMon Metrics Collector для мониторинга нагрузки на сервер (CPU, память) во время тестов.
        `,
        level: "INTERN"
      },
      {
        id: 5,
        question: "Что такое параметризация?",
        answer: `
          Параметризация — это процесс использования переменных вместо фиксированных данных в запросах. Это позволяет запускать тест с различными значениями (например, разные логины) для симуляции реальных пользователей.
      
          Пример из вашего проекта: В вашем файле JMeter используется User Defined Variables, где определены следующие переменные:
          - protocol = https
          - port = 443
          - host = profit-test.finportal-dev-2.salt.x5.ru
          - authHost = key-stage.x5.ru
          - client_id = finportal
          - username = [ваши данные]
      
          Эти переменные используются в запросах для построения URL и других параметров:
          \${protocol}://\${host}:\${port}/api/v1/data
      
          Таким образом, вместо фиксированного URL используются переменные, что облегчает изменение конфигурации и поддерживает гибкость тестирования.
        `,
        level: "INTERN"
      },
      {
        id: 6,
        question: "Что такое корреляция?",
        answer: `
          Корреляция — это извлечение динамических данных (например, токенов) из ответа одного запроса для последующего использования в другом запросе. Это необходимо, когда система генерирует уникальные данные для каждой сессии.
      
          Пример из вашего проекта: Предположим, что сервер возвращает токен авторизации в одном из запросов, который нужно использовать в дальнейшем для аутентификации. Для этого используется JSON Extractor:
          1. Добавьте JSON Extractor в запрос, где возвращается токен:
             - JSON Path: \$.access_token
             - Имя переменной: accessToken
          2. В следующих запросах используйте переменную для передачи токена:
          
          Authorization: Bearer \${accessToken}
          
          Теперь токен будет автоматически подставляться в каждый новый запрос, обеспечивая корректную работу теста.
        `,
        level: "INTERN"
      },
      {
        id: 6.1,
        question: "Виды проверок в JMeter",
        answer: `
          1. Response Assertion:
             Этот тип проверки применяется для того, чтобы убедиться, что ответ от сервера соответствует ожиданиям. Он позволяет проверять различные части ответа, такие как:
             - Код ответа HTTP (например, 200 OK или 404 Not Found).
             - Тело ответа — проверка на наличие или отсутствие конкретного текста, регулярного выражения, XML/JSON элемента.
             - Заголовки ответа — проверка заголовков (если требуется).
             - Сообщение об ошибке — проверка на отсутствие или наличие конкретного сообщения об ошибке.
      
             Способы проверок:
             - Поиск текста — проверка на наличие или отсутствие конкретного текста в ответе. Например, можно проверять, присутствует ли строка "Success" в теле ответа.
             - Регулярные выражения — проверка с помощью регулярных выражений для более гибкого поиска данных в теле ответа.
             - Коды ответов — проверка, что запрос вернул определенный HTTP статус-код, например, 200 для успешного выполнения.
      
          2. Size Assertion:
             Проверяет, что размер тела ответа больше или меньше указанного значения.
             Пример:
             - Проверка, что размер тела ответа меньше 5000 байт:
               - Add -> Assertions -> Size Assertion.
               - В поле "Size in bytes", установите значение 5000.
               - В разделе "Type of Comparison", выберите Less than.
      
          3. Duration Assertion:
             Проверяет, что время выполнения запроса не превышает определенного времени.
             Пример:
             - Проверка, что запрос выполнен не более чем за 2 секунды:
               - Add -> Assertions -> Duration Assertion.
               - В поле "Duration (in milliseconds)", установите значение 2000.
      
          4. XPath Assertion:
             Проверяет содержимое XML-ответа с использованием XPath, чтобы найти или проверить наличие конкретных элементов.
             Пример:
             - Проверка, что XML-ответ содержит элемент <status>Success</status>:
               - Add -> Assertions -> XPath Assertion.
               - В поле "XPath", установите следующее выражение:
                 \`//status[text()='Success']\`
      
          5. JSON Assertion:
             Используется для проверки содержимого JSON-ответов.
             Пример:
             - Проверка, что JSON-ответ содержит поле "status": "Success":
               - Add -> Post Processors -> JSON Extractor (для извлечения значения).
               - Используйте "JSON Assertion" и укажите путь:
                 \`$.status\`
               - Проверка, что status равен Success.
      
          6. JSR223/BeanShell Assertion:
             Позволяет использовать скрипты для кастомных проверок. Например, скрипт на Groovy для проверки динамических значений.
             Пример:
             - Проверка, что длина тела ответа больше 100 символов (JSR223 Assertion):
               - Add -> Assertions -> JSR223 Assertion.
               - Введите скрипт на Groovy:
                 \`if (prev.getResponseDataAsString().length() <= 100) {
                     AssertionResult.setFailure(true);
                     AssertionResult.setFailureMessage("Response length is less than or equal to 100");
                 }\`
        `,
        level: "INTERN"
      },
    {
        id: 7,
        question: "Определение профиля НТ и методы его сбора",
        answer: `
          <p>Профиль нагрузки — это набор операций с заданными интенсивностями, полученный на основе сбора статистических данных либо определенный путем анализа требований к тестируемой системе.</p>
          <p><strong>Методы сбора профиля НТ:</strong></p>
          <ul>
            <li><strong>Анализ бизнес-требований:</strong> Сбор данных о прогнозируемом количестве пользователей и типичных сценариях использования.</li>
            <li><strong>Логирование реальных пользователей:</strong> Анализ логов реальных систем для определения характерных нагрузок.</li>
            <li><strong>Анализ мониторинга системы:</strong> Использование данных мониторинга производительности (например, Grafana, Prometheus) для понимания, как система работает под нагрузкой.</li>
            <li><strong>Консультации с разработчиками и бизнес-аналитиками:</strong> Определение критичных операций и нагрузочных сценариев.</li>
          </ul>
        `,
        level: "INTERN"
      },
      {
        id: 8,
        question: "Перечень основных тестов нагрузочного тестирования и их цели",
        answer: `
          <ul>
            <li><strong>Тест на максимальную нагрузку:</strong> Определение предела, при котором система перестает справляться с запросами. Цель — найти узкие места.</li>
            <li><strong>Тест стабильности:</strong> Проверка работы системы при постоянной нагрузке в течение длительного времени (например, 10 часов). Цель — выявить проблемы с утечкой памяти и нестабильностью работы.</li>
            <li><strong>Стрессовое тестирование:</strong> Тестирование системы при экстремальных условиях, когда ее ресурсы могут быть исчерпаны. Основная цель — проверка устойчивости системы при экстремальных условиях.</li>
            <li><strong>Тестирование отказоустойчивости:</strong> Оценка способности системы сохранять работоспособность в условиях неблагоприятных факторов, таких как сбои в сети и отключение серверов.</li>
          </ul>
        `,
        level: "INTERN"
      },
      {
        id: 9,
        question: "Основные метрики, на которые смотрят в Grafana при нагрузочном тестировании",
        answer: `
          <ul>
            <li><strong>CPU Utilization:</strong> Показывает, сколько процессорных ресурсов использует система.</li>
            <li><strong>Memory Utilization:</strong> Показывает использование оперативной памяти, важно, чтобы оно не превышало 80%.</li>
            <li><strong>Request Rate (RPS):</strong> Количество запросов в секунду, которые система обрабатывает.</li>
            <li><strong>Response Time:</strong> Время отклика системы, особенно важно для критичных операций.</li>
            <li><strong>Error Rate:</strong> Процент ошибок в системе, следует отслеживать, чтобы он был ниже 1%.</li>
            <li><strong>Throughput:</strong> Пропускная способность системы, измеряемая в мегабайтах или гигабайтах в секунду.</li>
          </ul>
        `,
        level: "INTERN"
      },
      {
        id: 10,
        question: "Статистика базы данных",
        answer: `
          <ul>
            <li><strong>Количество запросов:</strong> Общее количество SQL-запросов, обрабатываемых базой данных.</li>
            <li><strong>Время выполнения запросов:</strong> Показывает среднее, максимальное и минимальное время выполнения запросов.</li>
            <li><strong>Количество соединений:</strong> Количество активных соединений к базе данных.</li>
            <li><strong>Закэшированные данные:</strong> Статистика использования кэша для ускорения выполнения запросов.</li>
            <li><strong>Использование индексов:</strong> Статистика использования индексов для оптимизации запросов.</li>
            <li><strong>Количество блокировок:</strong> Блокировки строк или таблиц, замедляющие работу базы данных.</li>
          </ul>
        `,
        level: "INTERN"
      },
      {
        id: 11,
        question: "Различия между реляционной и нереляционной БД",
        answer: `
        <p>База данных (БД) — это организованная коллекция данных, предназначенная для хранения, управления и обработки информации. Базы данных позволяют эффективно сохранять большие объёмы данных, легко находить нужные сведения и управлять ими. Базы данных могут быть реляционными и нереляционными</p>
          <ul>
            <li><strong>Реляционные базы данных (RDBMS):</strong> организуют данные в таблицы с четко определенной схемой (строки и столбцы). Они поддерживают сложные связи между таблицами с помощью первичных и внешних ключей, что делает их идеальными для работы с четко структурированными данными и сложными взаимосвязями. Для работы с данными используют язык SQL. Примеры: MySQL, PostgreSQL, Oracle, SQL Server.</li>
            <li><strong>Нереляционные базы данных (NoSQL):</strong> могут хранить данные в различных форматах — документы, графы, ключ-значение или столбцы — без строгой схемы. Обычно они не поддерживают сложные связи, но хорошо масштабируются и оптимизированы для быстрого доступа к большим объемам неструктурированных данных. Примеры: MongoDB, Cassandra, Redis, Couchbase.</li>
          </ul>
        `,
        level: "INTERN"
      },
      {
        id: 12,
        question: "Как посмотреть, что находится в конкретной таблице?",
        answer: `
          <p>Для этого можно использовать следующий SQL-запрос:</p>
          <pre><code>SELECT * FROM table_name;</code></pre>
          <p>Здесь <code>table_name</code> — это название таблицы, данные которой нужно посмотреть.</p>
        `,
        level: "INTERN"
      },
      {
        id: 13,
        question: "Как выбрать конкретные столбцы?",
        answer: `
          <p>Для этого нужно указать конкретные столбцы в SQL-запросе:</p>
          <pre><code>SELECT column1, column2 FROM table_name;</code></pre>
          <p>Пример:</p>
          <pre><code>SELECT first_name, last_name FROM employees;</code></pre>
        `,
        level: "INTERN"
      },
      {
        id: 14,
        question: "Как писать условия для фильтрации? (WHERE)",
        answer: `
          <p>Для фильтрации данных используется ключевое слово <code>WHERE</code>:</p>
          <pre><code>SELECT * FROM table_name WHERE condition;</code></pre>
          <p>Пример:</p>
          <pre><code>SELECT * FROM employees WHERE salary > 50000;</code></pre>
        `,
        level: "INTERN"
      },
      {
        id: 15,
        question: "Что такое HTTP протокол?",
        answer: `
          <p><strong>HTTP (HyperText Transfer Protocol)</strong> — это протокол прикладного уровня, который используется для передачи данных в интернете. Он обеспечивает взаимодействие между клиентом (например, браузером) и сервером, работая по принципу "запрос-ответ". Этот протокол передаёт данные, такие как текст, изображения, видео и другие форматы, используя протоколы TCP/IP для доставки.</p>
          
          <h4>Как работает HTTP:</h4>
          <ol>
            <li><strong>Запрос клиента:</strong> Когда пользователь вводит URL в браузере или нажимает на ссылку, браузер отправляет HTTP-запрос на сервер. Запрос состоит из:
              <ul>
                <li>Метода (например, GET для получения данных или POST для отправки),</li>
                <li>URI (адреса ресурса, который запрашивается),</li>
                <li>Версии HTTP (например, HTTP/1.1 или HTTP/2),</li>
                <li>Дополнительных заголовков (например, типы данных, которые браузер может принять).</li>
              </ul>
            </li>
            <li><strong>Роль DNS:</strong> Прежде чем отправить запрос, браузер обращается к DNS (Domain Name System), чтобы преобразовать URL (например, www.example.com) в IP-адрес сервера.</li>
            <li><strong>Обработка на сервере:</strong> После получения запроса сервер обрабатывает его и возвращает HTTP-ответ, который состоит из:
              <ul>
                <li>Статуса ответа (например, 200 OK означает успешное выполнение),</li>
                <li>Заголовков (например, Content-Type — тип возвращаемого содержимого, и Content-Length — его размер),</li>
                <li>Тела ответа, которое может содержать запрашиваемую HTML-страницу или другой ресурс.</li>
              </ul>
            </li>
            <li><strong>Ответ сервера:</strong> Сервер отправляет данные обратно клиенту через тот же протокол TCP/IP. Браузер принимает данные и отображает их пользователю.</li>
          </ol>
          
          <h4>Безопасность в HTTP:</h4>
          <p>HTTPS — это защищённая версия HTTP, которая использует шифрование данных с помощью протоколов TLS (Transport Layer Security). Это необходимо для безопасной передачи данных, таких как пароли или информация о банковских картах. В отличие от HTTP, в HTTPS данные перед отправкой шифруются, что защищает их от перехвата.</p>
          
          <h4>Пример использования:</h4>
          <p>Когда вы вводите URL в браузере, например, https://www.example.com, браузер отправляет HTTPS-запрос на сервер, где данные шифруются и защищаются от несанкционированного доступа, а сервер возвращает зашифрованный ответ с запрашиваемыми данными.</p>
          
          <p>Таким образом, HTTP — это основа веб-связи, которая работает на уровне запросов и ответов, а HTTPS обеспечивает безопасность передачи данных в интернете.</p>
          
          <p>Источник: <a href="https://skillbox.ru/media/code/chto-takoe-http-i-zachem-on-nuzhen/" target="_blank">https://skillbox.ru/media/code/chto-takoe-http-i-zachem-on-nuzhen/</a></p>
        `,
        level: "INTERN"
      },
      {
        id: 16,
        question: "Что такое Request?",
        answer: "Request (Запрос) — это сообщение от клиента к серверу для получения данных или выполнения операций.",
        level: "INTERN"
      },
      {
        id: 17,
        question: "Что такое Response?",
        answer: "Response (Ответ) — это сообщение, которое сервер отправляет в ответ на запрос клиента.",
        level: "INTERN"
      },
      {
        id: 18,
        question: "Что такое Headers?",
        answer: "Headers (Заголовки) — это метаинформация, передаваемая в запросах и ответах HTTP.",
        level: "INTERN"
      },
      {
        id: 19,
        question: "Что такое Cookie?",
        answer: "Cookie — это небольшие данные, которые сервер отправляет клиенту для хранения информации о сессиях и настройках.",
        level: "INTERN"
      },
      {
        id: 20,
        question: "Что такое Body?",
        answer: "Body (Тело) — это основное содержимое HTTP-запроса или ответа, содержащее данные.",
        level: "INTERN"
      },
      {
        id: 21,
        question: "Что такое Method?",
        answer: `
          <ul>
            <li><strong>GET:</strong> Получить данные с сервера.</li>
            <li><strong>POST:</strong> Отправить данные на сервер.</li>
            <li><strong>PUT:</strong> Обновить или создать ресурс на сервере.</li>
            <li><strong>DELETE:</strong> Удалить ресурс на сервере.</li>
            <li><strong>PATCH:</strong> Частичное обновление ресурса.</li>
          </ul>
        `,
         level: "INTERN"
      },
      {
        id: 22,
        question: "Коды состояния и текст статуса",
        answer: `
          <ul>
            <li><strong>200 OK:</strong> Запрос успешно выполнен.</li>
            <li><strong>201 Created:</strong> Запрос выполнен успешно, создан новый ресурс.</li>
            <li><strong>404 Not Found:</strong> Ресурс не найден.</li>
            <li><strong>500 Internal Server Error:</strong> На сервере произошла ошибка.</li>
          </ul>
        `,
         level: "INTERN"
      },
      {
        id: 24,
        question: "Простые циклы с условиями на Python и Java",
        answer: `
          <p><strong>Цикл с условием while (Python):</strong></p>
          <pre><code>i = 0\nwhile i < 5:\n    if i % 2 == 0:\n        print(f"{i} is even")\n    else:\n        print(f"{i} is odd")\n    i += 1</code></pre>
          
          <p><strong>Цикл с условием while (Java):</strong></p>
          <pre><code>int i = 0;\nwhile (i < 5) {\n    if (i % 2 == 0) {\n        System.out.println(i + " is even");\n    } else {\n        System.out.println(i + " is odd");\n    }\n    i++;\n}</code></pre>
        `,
         level: "INTERN"
      },
      {
        id: 25,
        question: "Реализация простейших алгоритмов на Python и Java",
        answer: `
          <p><strong>Алгоритм нахождения максимума в списке (Python):</strong></p>
          <pre><code>def find_max(arr):\n    max_value = arr[0]\n    for num in arr:\n        if num > max_value:\n            max_value = num\n    return max_value\n\nnumbers = [3, 5, 1, 9, 2]\nprint(find_max(numbers))  # Вывод: 9</code></pre>
          
          <p><strong>Алгоритм нахождения максимума в массиве (Java):</strong></p>
          <pre><code>public class Main {\n    public static int findMax(int[] arr) {\n        int maxValue = arr[0];\n        for (int num : arr) {\n            if (num > maxValue) {\n                maxValue = num;\n            }\n        }\n        return maxValue;\n    }\n\n    public static void main(String[] args) {\n        int[] numbers = {3, 5, 1, 9, 2};\n        System.out.println(findMax(numbers));  // Вывод: 9\n    }\n}</code></pre>
        `,
         level: "INTERN"
      },
      {
        id: 26,
        question: "Функции работы с массивами на Python и Java",
        answer: `
          <p><strong>Обращение массива (Python):</strong></p>
          <pre><code>arr = [1, 2, 3, 4, 5]\nreversed_arr = arr[::-1]  # Метод срезов\nprint(reversed_arr)  # Вывод: [5, 4, 3, 2, 1]</code></pre>
          
          <p><strong>Обращение массива (Java):</strong></p>
          <pre><code>public class Main {\n    public static void reverseArray(int[] arr) {\n        for (int i = 0; i < arr.length / 2; i++) {\n            int temp = arr[i];\n            arr[i] = arr[arr.length - 1 - i];\n            arr[arr.length - 1 - i] = temp;\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, 4, 5};\n        reverseArray(arr);\n        for (int num : arr) {\n            System.out.print(num + " ");  // Вывод: 5 4 3 2 1\n        }\n    }\n}</code></pre>
        `,
         level: "INTERN"
      },
      {
        id: 27,
        question: "Как правильно использовать функции корреляции, проверок и границ транзакций в JMeter или другом инструменте нагрузочного тестирования?",
        answer: `
          <p><strong>JMeter:</strong></p>
          <ul>
            <li><strong>Корреляция:</strong> Это процесс захвата динамических данных из ответов сервера и их использования в последующих запросах.</li>
            <li>Пример в JMeter:</li>
            <pre><code>
              В JMeter используется Regular Expression Extractor для извлечения нужных данных. 
              Пример: после успешного входа в систему может быть возвращен уникальный токен сессии. Этот токен нужно захватить и передать в каждом последующем запросе для аутентификации.
            </code></pre>
            <li><strong>Проверки (Assertions):</strong> Позволяют убедиться, что система работает правильно, используя Response Assertion для проверки текста ответа или статус-кодов.</li>
            <li><strong>Границы транзакций (Transaction Controller):</strong> Измеряет время выполнения определённой группы запросов как одну транзакцию.</li>
          </ul>
    
          <p><strong>Locust:</strong></p>
          <ul>
            <li><strong>Корреляция:</strong> Выполняется вручную через парсинг ответов, используя библиотеки Python.</li>
            <pre><code>
              from locust import HttpUser, task
              
              class MyUser(HttpUser):
                  @task
                  def my_task(self):
                      response = self.client.get("/login")
                      token = response.json()["token"]
                      self.client.post("/submit", json={"token": token})
            </code></pre>
            <li><strong>Проверки:</strong> В Locust делаются вручную, как в обычном Python-коде.</li>
            <pre><code>
              class MyUser(HttpUser):
                  @task
                  def my_task(self):
                      response = self.client.get("/api/data")
                      assert response.status_code == 200, "Неправильный статус-код"
                      assert "expected_value" in response.text, "Ожидаемое значение не найдено"
            </code></pre>
            <li><strong>Границы транзакций:</strong> Используйте таймеры для измерения времени выполнения задач.</li>
            <pre><code>
              import time
              from locust import HttpUser, task
    
              class MyUser(HttpUser):
                  @task
                  def my_task(self):
                      start_time = time.time()
                      self.client.get("/api/data")
                      end_time = time.time()
                      elapsed_time = end_time - start_time
                      print(f"Время выполнения транзакции: {elapsed_time} секунд")
            </code></pre>
          </ul>
    
          <p><strong>Gatling:</strong></p>
          <ul>
            <li><strong>Корреляция:</strong> Динамические значения можно извлекать с помощью встроенных методов, таких как <code>check</code> и <code>saveAs</code>.</li>
            <li><strong>Проверки:</strong> Используются <code>Checks</code>, например, для проверки кода ответа.</li>
            <li><strong>Границы транзакций:</strong> Транзакции автоматически измеряются, но можно добавить тайминги с помощью <code>exec().startTimer().stopTimer()</code>.</li>
          </ul>
        `,
        level: "JUNIOR"
      },
      {
        id: 28,
        question: "Что такое пейсинг?",
        answer: `
          <p>Пейсинг — это интервал времени между выполнением последовательных действий одного и того же виртуального пользователя в нагрузочном тесте. Пейсинг контролирует интенсивность нагрузки.</p>
        `,
        level: "JUNIOR"
      },
      {
        id: 29,
        question: "Как правильно вычислять пейсинг и количество пользователей?",
        answer: `
          <p>Формула пейсинга:</p>
          <pre><code>
            Пейсинг = (60 / Целевая нагрузка) - Время выполнения сценария
          </code></pre>
          <p>Пример:</p>
          <ul>
            <li>Целевая нагрузка: 1000 запросов в минуту</li>
            <li>100 пользователей</li>
            <li>Среднее время выполнения: 5 секунд</li>
          </ul>
        `,
        level: "JUNIOR"
      },
      {
        id: 29.1,
        question: "Как правильно вычислить количество виртуальных пользователей и пейсинг?",
        answer: `
          Для правильного расчета количества виртуальных пользователей и пейсинга нужно учитывать следующие параметры:
      
          1. **Количество виртуальных пользователей (Vusers):**
             - Количество виртуальных пользователей зависит от того, сколько пользователей вы хотите симулировать в реальной системе.
             - Для расчета количества виртуальных пользователей можно использовать следующую формулу:
               \`Vusers = (R * T) / P\`, где:
               - \`R\` — это желаемое количество запросов в секунду (RPS),
               - \`T\` — это время выполнения одного сценария (в секундах),
               - \`P\` — это пейсинг, то есть интервал между выполнением сценариев пользователями.
      
          2. **Пейсинг (Pacing):**
             - Пейсинг — это интервал времени между последовательными выполнениями сценариев одним пользователем.
             - Чтобы вычислить пейсинг, необходимо учитывать желаемую нагрузку на систему и количество пользователей.
             - Формула для расчета пейсинга:
               \`P = (T * Vusers) / R\`, где:
               - \`P\` — это пейсинг (время между началом одного и начала следующего сценария),
               - \`T\` — это время выполнения одного цикла сценария (в секундах),
               - \`Vusers\` — это количество виртуальных пользователей,
               - \`R\` — это желаемое количество запросов в секунду.
      
          **Пример расчета:**
          - Допустим, вам нужно симулировать 1000 запросов в минуту (R = 1000 / 60 = ~16.67 RPS).
          - Если сценарий одного пользователя выполняется за 5 секунд (T = 5),
          - И вы хотите использовать 100 виртуальных пользователей (Vusers = 100),
          
          Тогда пейсинг можно рассчитать как:
          \`P = (T * Vusers) / R = (5 * 100) / 16.67 = ~30 секунд\`.
      
          Это значит, что каждый виртуальный пользователь должен запускать сценарий каждые 30 секунд, чтобы достичь 1000 запросов в минуту.
        `,
        level: "JUNIOR"
      },
      {
        id: 29.2,
        question: "Что такое сущность в БД?",
        answer: `
          Сущность в базе данных (БД) — это объект или концепция, которая представляет собой некоторую информацию, которую необходимо хранить в системе. В контексте реляционных баз данных сущность обычно отображается в виде таблицы, где каждая строка представляет собой запись (экземпляр сущности), а столбцы — атрибуты (свойства) сущности.
      
          Основные характеристики сущности:
          1. Сущность — это объект, который может быть идентифицирован в системе. Примеры сущностей: пользователи, заказы, товары, транзакции и т.д.
          2. Атрибуты сущности — это характеристики, которые описывают сущность. Например, сущность "Пользователь" может иметь атрибуты, такие как имя, электронная почта, возраст и т.д.
          3. Экземпляры сущности — это конкретные записи в таблице базы данных. Например, каждый пользователь в таблице "Пользователи" — это экземпляр сущности "Пользователь".
      
          Пример:
          Для сущности "Пользователь" может быть создана таблица в базе данных, которая содержит следующие атрибуты:
          - id (идентификатор пользователя),
          - first_name (имя),
          - last_name (фамилия),
          - email (электронная почта).
      
          Пример таблицы "Пользователи":
          \`\`\`
          id   first_name  last_name  email
          1    Иван        Иванов     ivan@example.com
          2    Ольга       Смирнова   olga@example.com
          \`\`\`
      
          В данном случае сущность — это "Пользователь", а каждая строка таблицы представляет собой конкретного пользователя, то есть экземпляр этой сущности.
      
          Заключение:
          Сущность — это ключевая концепция в базах данных, которая отражает объекты, с которыми работает система, и хранит информацию о них в виде записей (строк) в таблицах.
        `,
        level: "JUNIOR"
      },
      {
        id: 30,
        question: "Как снять статистику с базы данных (PostgreSQL)?",
        answer: `
          <ul>
            <li>Включите расширение <code>pg_stat_statements</code> в конфигурации PostgreSQL:</li>
            <pre><code>shared_preload_libraries = 'pg_stat_statements'</code></pre>
            <li>Запрос для мониторинга производительности баз данных:</li>
            <pre><code>
              SELECT * FROM pg_stat_statements;
            </code></pre>
            <li>Запрос для мониторинга текущих активных запросов:</li>
            <pre><code>
              SELECT * FROM pg_stat_activity;
            </code></pre>
          </ul>
        `,
        level: "JUNIOR"
      },
      {
        id: 31,
        question: "Что такое многопоточность в приложениях?",
        answer: `
          <p>Многопоточность — это способность приложения выполнять несколько задач одновременно (параллельно) с использованием нескольких потоков. Программы, которые могут одновременно выполнять несколько задач, используя для этого разные потоки. Такие приложения обычно используются для улучшения производительности и эффективности работы.</p>
          <p>В контексте многопоточности, поток — это отдельная последовательность инструкций, которая выполняется параллельно с другими потоками в пределах одного процесса.</p>
          <h4>Основные характеристики потока:</h4>
          <ol>
            <li><strong>Легковесный процесс:</strong> Поток может рассматриваться как "легковесный" процесс, который разделяет память и ресурсы с другими потоками в одном процессе.</li>
            <li><strong>Совместное использование ресурсов:</strong> Все потоки в одном процессе используют общую память, что позволяет обмениваться данными между ними быстрее, чем между отдельными процессами.</li>
            <li><strong>Параллелизм:</strong> В многопоточном приложении несколько потоков могут выполняться одновременно, что улучшает производительность за счёт использования нескольких процессоров или ядер.</li>
          </ol>
          <p><strong>В контексте определения:</strong></p>
          <p>В многопоточном приложении потоки используются для выполнения нескольких задач параллельно. Например, один поток может обрабатывать пользовательский ввод, в то время как другой выполняет сетевые запросы или вычисления. Это помогает более эффективно использовать ресурсы системы и улучшать отзывчивость приложения.</p>
          <h4>Пример:</h4>
          <p>В веб-сервере каждый запрос может обрабатываться отдельным потоком, что позволяет серверу одновременно обслуживать несколько клиентов.</p>
        `,
        level: "JUNIOR"
      },
      {
        id: 31.1,
        question: "Какой есть предел потоков у приложения?",
        answer: `
          <p>Предел количества потоков у приложения зависит от нескольких факторов, включая ресурсы системы и настройки операционной системы. Хотя теоретически можно создать очень много потоков, на практике существуют ограничения, которые зависят от следующих аспектов:</p>
          <ol>
            <li><strong>Ограничения операционной системы:</strong>
              <ul>
                <li>Операционная система устанавливает ограничения на количество потоков, которые можно запустить в одном процессе. Это ограничение зависит от архитектуры системы, настройки ядра, доступных ресурсов (памяти, CPU).</li>
                <li>В системах Linux и Windows есть параметры, которые можно настроить для увеличения или уменьшения количества допустимых потоков.</li>
              </ul>
            </li>
            <li><strong>Память:</strong>
              <ul>
                <li>Каждый поток требует выделения памяти для своего стека (обычно от 256 КБ до 1 МБ на поток). Чем больше потоков, тем больше оперативной памяти требуется для их поддержания.</li>
                <li>Если количество потоков превышает возможности системы по памяти, это приведет к OutOfMemoryError или другим ошибкам, связанным с нехваткой ресурсов.</li>
              </ul>
            </li>
            <li><strong>Ресурсы процессора (CPU):</strong>
              <ul>
                <li>Количество ядер процессора влияет на эффективность многопоточных приложений. Большое количество потоков может приводить к "контекстным переключениям", когда процессор переключается между потоками, что снижает производительность. Хотя можно создать много потоков, они не будут одновременно выполняться, если не хватает физических или логических ядер.</li>
              </ul>
            </li>
            <li><strong>Конфигурации JVM (для Java-приложений):</strong>
              <ul>
                <li>В Java приложениям можно задать предел количества потоков через параметры JVM, такие как -Xss (размер стека для потока). Например, уменьшив размер стека потока, можно создать больше потоков, но это приведет к меньшему количеству доступной памяти для каждого потока.</li>
              </ul>
            </li>
          </ol>
          <h4>Пример практических ограничений:</h4>
          <ul>
            <li><strong>В 32-битных системах:</strong> Ограничение на количество потоков может быть около 1000-2000, так как 32-битная система имеет ограниченный объём памяти.</li>
            <li><strong>В 64-битных системах:</strong> Количество потоков может быть значительно больше (десятки тысяч), так как 64-битная система поддерживает больше памяти.</li>
          </ul>
        `,
        level: "JUNIOR"
      },
      {
        id: 31.2,
        question: "Чем отличается виртуальный пользователь(Thread) от потока внутри приложения?",
        answer: `
          <p><strong>Виртуальный пользователь (Thread)</strong> в нагрузочном тестировании и поток внутри приложения — это два разных понятия, хотя и имеют похожие принципы работы.</p>
          <h4>1. Виртуальный пользователь (Thread) в нагрузочном тестировании:</h4>
          <ul>
            <li><strong>Определение:</strong> Виртуальный пользователь (VU, виртуальный поток) в таких инструментах, как JMeter или Locust, — это эмуляция действий одного пользователя, который взаимодействует с системой. Он имитирует реальных пользователей, отправляя запросы на сервер для тестирования его производительности.</li>
            <li><strong>Назначение:</strong> Основная задача виртуальных пользователей — создать нагрузку на систему, чтобы оценить её поведение под различной интенсивностью запросов (например, при 100, 1000 или 10 000 пользователей).</li>
            <li><strong>Особенности:</strong>
              <ul>
                <li>Виртуальные пользователи могут запускаться параллельно, но не обязательно напрямую связаны с многопоточностью внутри приложения.</li>
                <li>Каждый виртуальный пользователь может выполнять сценарий теста, который включает последовательность действий (например, логин, запрос данных, выход).</li>
                <li>В JMeter или Locust виртуальные пользователи настраиваются через Thread Group, которая указывает, сколько "пользователей" будет одновременно выполнять тестовые сценарии.</li>
              </ul>
            </li>
          </ul>
          <h4>2. Поток внутри приложения:</h4>
          <ul>
            <li><strong>Определение:</strong> Поток (thread) в контексте многопоточности приложения — это "параллельная" единица выполнения, которая работает в одном процессе. Потоки внутри приложения делят общую память и ресурсы между собой и могут выполнять различные задачи одновременно.</li>
            <li><strong>Назначение:</strong> Потоки в приложении используются для повышения производительности и эффективности. Например, один поток может обрабатывать пользовательский ввод, другой — выполнять вычисления, третий — ждать ответа от сервера.</li>
            <li><strong>Особенности:</strong>
              <ul>
                <li>Потоки внутри приложения делят между собой общие ресурсы, такие как память, что требует тщательной синхронизации, чтобы избежать конфликтов.</li>
                <li>Потоки используют процессорные ресурсы и могут выполнять задачи параллельно, если система поддерживает многопоточность.</li>
                <li>Управление потоками осуществляется через код приложения, и их выполнение может быть более сложным, так как нужно учитывать синхронизацию и управление доступом к общим ресурсам.</li>
              </ul>
            </li>
          </ul>
          <h4>Основные отличия:</h4>
          <table>
            <thead>
              <tr>
                <th>Критерий</th>
                <th>Виртуальный пользователь (Thread в нагрузочном тестировании)</th>
                <th>Поток внутри приложения (Thread)</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Назначение</td>
                <td>Имитация действий реальных пользователей для тестирования нагрузки на систему</td>
                <td>Выполнение нескольких задач одновременно внутри одного процесса</td>
              </tr>
              <tr>
                <td>Контекст работы</td>
                <td>Работает как независимая сущность, выполняя сценарий теста, взаимодействуя с сервером</td>
                <td>Выполняет задачи в рамках одного процесса, может делить память и ресурсы с другими потоками</td>
              </tr>
              <tr>
                <td>Взаимодействие с системой</td>
                <td>Отправляет HTTP-запросы или выполняет другие действия для создания нагрузки</td>
                <td>Выполняет вычисления, операции ввода-вывода, обработку данных и др. внутри программы</td>
              </tr>
              <tr>
                <td>Управление</td>
                <td>Настраивается через инструменты тестирования (например, JMeter, Locust)</td>
                <td>Управляется разработчиками через код приложения</td>
              </tr>
              <tr>
                <td>Ресурсы</td>
                <td>Использует ресурсы тестирующего инструмента и создаёт нагрузку на сервер</td>
                <td>Использует процессорные ресурсы и память приложения, требуя синхронизации</td>
              </tr>
            </tbody>
          </table>
          <h4>Пример:</h4>
          <ul>
            <li><strong>Виртуальный пользователь:</strong> В JMeter может отправлять HTTP-запросы, имитируя поведение пользователя, заходящего на веб-сайт, отправляя запросы и получая ответы.</li>
            <li><strong>Поток внутри приложения:</strong> В Java может одновременно обрабатывать запросы от нескольких пользователей, где один поток работает с базой данных, а другой отправляет данные обратно пользователю.</li>
          </ul>
          <p><strong>Заключение:</strong> Виртуальный пользователь в нагрузочном тестировании — это инструмент для имитации реальных пользователей, создающий нагрузку на систему. Поток внутри приложения — это механизм параллельного выполнения задач в одном процессе программы, который повышает производительность работы приложения.</p>
        `,
        level: "JUNIOR"
      },
      {
        id: 31.3,
        question: "Например, у нас залогинились 1000 виртуальных пользователей одновременно, сколько будет потоков?",
        answer: `
          <p>Если у вас 1000 виртуальных пользователей в JMeter, это создаст 1000 потоков в самом JMeter, каждый из которых будет выполнять свои действия параллельно (например, логин).</p>
          <p>Однако на сервере количество потоков будет зависеть от его настроек. Сервер может использовать пул потоков (например, 200 потоков), и обрабатывать запросы по очереди, а не все одновременно.</p>
          <p>То есть:</p>
          <ul>
            <li>1000 виртуальных пользователей в JMeter = 1000 потоков в JMeter.</li>
            <li>Сервер может иметь меньше потоков, в зависимости от своей конфигурации.</li>
          </ul>
        `,
        level: "JUNIOR"
      },
      {
        id: 31.4,
        question: "Пул коннектов это?",
        answer: `
          <p><strong>Пул коннектов</strong> — это механизм управления соединениями с базой данных или другим ресурсом, который позволяет многократно использовать созданные соединения. Вместо того чтобы каждый раз создавать и закрывать соединение, пул коннектов сохраняет несколько активных соединений, готовых к использованию, и предоставляет их по запросу.</p>
          <h4>Основные характеристики:</h4>
          <ul>
            <li><strong>Повторное использование:</strong> Соединения не создаются каждый раз заново, а берутся из пула.</li>
            <li><strong>Эффективность:</strong> Экономится время на создание и закрытие соединений, что улучшает производительность приложения.</li>
            <li><strong>Ограничение ресурсов:</strong> Пул управляет количеством одновременно активных соединений, чтобы не перегружать базу данных.</li>
          </ul>
          <h4>Пример:</h4>
          <p>Приложение может создать пул из 10 коннектов. Когда пользователю нужно соединение с базой данных, оно берётся из пула. После завершения работы соединение возвращается в пул для повторного использования другими пользователями.</p>
        `,
        level: "JUNIOR"
      },      
      {
        id: 32,
        question: "Что такое уровни логирования?",
        answer: `
          <ul>
            <li><strong>TRACE:</strong> Самый детализированный уровень.</li>
            <li><strong>DEBUG:</strong> Отладочная информация.</li>
            <li><strong>INFO:</strong> Общая информация о работе приложения.</li>
            <li><strong>WARN:</strong> Предупреждения о возможных проблемах.</li>
            <li><strong>ERROR:</strong> Ошибки, которые требуют внимания.</li>
            <li><strong>FATAL:</strong> Критические ошибки, приводящие к завершению работы приложения.</li>
          </ul>
        `,
        level: "JUNIOR"
      },
      {
        id: 32.1,
        question: "Что такое парсинг логов?",
        answer: `
          Парсинг логов — это процесс автоматического анализа и обработки лог-файлов с целью извлечения полезной информации, такой как ошибки, предупреждения, статистика производительности, успешные или неуспешные операции. Лог-файлы обычно содержат информацию о работе системы, которая записывается в текстовые файлы. Парсинг помогает структурировать эти данные и использовать их для мониторинга, анализа и отладки.
      
          Основные задачи парсинга логов:
          1. **Поиск ошибок:** Автоматическое извлечение и классификация ошибок, которые произошли в системе.
          2. **Мониторинг производительности:** Сбор данных о времени отклика, загрузке системы и других метриках из логов.
          3. **Фильтрация данных:** Удаление ненужной информации и извлечение только тех данных, которые важны для анализа.
          4. **Анализ событий:** Определение последовательности событий и их влияние на производительность или стабильность системы.
        `,
        level: "JUNIOR"
      },
      {
        id: 33,
        question: "Простые запросы с помощью SELECT",
        answer: `
          <ul>
            <li>Получение всех строк из таблицы:</li>
            <pre><code>SELECT * FROM employees;</code></pre>
            <li>Получение конкретных столбцов:</li>
            <pre><code>SELECT first_name, last_name FROM employees;</code></pre>
            <li>Фильтрация с использованием WHERE:</li>
            <pre><code>SELECT * FROM employees WHERE age > 30;</code></pre>
          </ul>
        `,
        level: "JUNIOR"
      },
      {
        id: 34,
        question: "Использование функций JOIN, GROUP BY, HAVING",
        answer: `
          <ul>
            <li><strong>JOIN:</strong> Объединение данных из двух таблиц.</li>
            <pre><code>
              SELECT employees.first_name, departments.department_name
              FROM employees
              INNER JOIN departments ON employees.department_id = departments.id;
            </code></pre>
            <li><strong>GROUP BY:</strong> Группировка строк по столбцам.</li>
            <pre><code>
              SELECT department_id, COUNT(*)
              FROM employees
              GROUP BY department_id;
            </code></pre>
            <li><strong>HAVING:</strong> Фильтрация результатов после группировки.</li>
            <pre><code>
              SELECT department_id, COUNT(*)
              FROM employees
              GROUP BY department_id
              HAVING COUNT(*) > 5;
            </code></pre>
          </ul>
        `,
        level: "JUNIOR"
      },
      {
      id: 35,
      question: "Что такое агрегирование функций?",
      answer: `
        <p>Агрегатные функции — это функции, которые применяются к группе строк и возвращают одно значение для каждой группы. Часто используются вместе с <code>GROUP BY</code>.</p>
        <ul>
          <li><strong>COUNT():</strong> Возвращает количество строк.</li>
          <pre><code>SELECT COUNT(*) FROM employees;</code></pre>
          <li><strong>SUM():</strong> Возвращает сумму значений в столбце.</li>
          <pre><code>SELECT SUM(salary) FROM employees;</code></pre>
          <li><strong>AVG():</strong> Возвращает среднее значение.</li>
          <pre><code>SELECT AVG(salary) FROM employees;</code></pre>
          <li><strong>MAX():</strong> Возвращает максимальное значение.</li>
          <pre><code>SELECT MAX(salary) FROM employees;</code></pre>
          <li><strong>MIN():</strong> Возвращает минимальное значение.</li>
          <pre><code>SELECT MIN(salary) FROM employees;</code></pre>
        </ul>
        <p>Пример объединения всех функций:</p>
        <pre><code>
          SELECT department_id, AVG(salary), MAX(salary), MIN(salary)
          FROM employees
          GROUP BY department_id
          HAVING AVG(salary) > 50000;
        </code></pre>
        <p>Этот запрос группирует сотрудников по отделам, вычисляет среднюю, максимальную и минимальную зарплату, и выводит только те отделы, где средняя зарплата больше 50 000.</p>
      `,
      level: "JUNIOR"
    },
    {
      id: 36,
      question: "Что такое Spring Boot?",
      answer: `
        <p><strong>Spring Boot</strong> — это фреймворк для упрощенной разработки Java-приложений с использованием экосистемы Spring. Он предоставляет встроенные механизмы для быстрой настройки и запуска приложений, минимизируя конфигурацию.</p>
        <p>Основные особенности Spring Boot:</p>
        <ul>
          <li><strong>Автоконфигурация:</strong> Автоматически настраивает компоненты приложения на основе зависимостей.</li>
          <li><strong>Встроенные серверы:</strong> Включает встроенные серверы, такие как Tomcat и Jetty.</li>
          <li><strong>Поддержка микросервисов:</strong> Легко использовать для создания микросервисов.</li>
        </ul>
        <p>Пример простого Spring Boot приложения:</p>
        <pre><code class="language-java">
          import org.springframework.boot.SpringApplication;
          import org.springframework.boot.autoconfigure.SpringBootApplication;
          import org.springframework.web.bind.annotation.GetMapping;
          import org.springframework.web.bind.annotation.RestController;
  
          @SpringBootApplication
          public class MySpringBootApplication {
  
            public static void main(String[] args) {
              SpringApplication.run(MySpringBootApplication.class, args);
            }
  
            @RestController
            class MyController {
              @GetMapping("/hello")
              public String sayHello() {
                return "Hello, Spring Boot!";
              }
            }
          }
        </code></pre>
        <p>Этот код является простым примером Spring Boot приложения, которое запускает встроенный веб-сервер и предоставляет REST API с единственным HTTP-методом GET по пути <code>/hello</code>.</p>
      `,
      level: "JUNIOR"
    },
    {
      id: 37,
      question: "Что такое Apache Kafka и основные принципы?",
      answer: `
        <p><strong>Apache Kafka</strong> — это распределённая платформа потоковой передачи сообщений, используемая для создания высокопроизводительных систем реального времени.</p>
        <p>Основные принципы работы Apache Kafka:</p>
        <ul>
          <li><strong>Тема (Topic):</strong> Логический канал для организации сообщений в Kafka.</li>
          <li><strong>Производитель (Producer):</strong> Отправляет сообщения в тему Kafka.</li>
          <li><strong>Потребитель (Consumer):</strong> Читает сообщения из темы Kafka.</li>
          <li><strong>Разделы (Partitions):</strong> Темы разделены на несколько частей для параллельной обработки.</li>
          <li><strong>Репликация и отказоустойчивость:</strong> Kafka поддерживает репликацию данных для повышения надёжности.</li>
        </ul>
      `,
      level: "JUNIOR"
    },
    {
      id: 38,
      question: "Что такое Kubernetes и основные элементы?",
      answer: `
        <p><strong>Kubernetes (K8s)</strong> — это платформа для автоматизации развертывания и управления контейнеризованными приложениями.</p>
        <p>Основные элементы Kubernetes:</p>
        <ul>
          <li><strong>Кластер (Cluster):</strong> Группа серверов (узлов), на которых развернуты приложения.</li>
          <li><strong>Под (Pod):</strong> Базовая единица развертывания в Kubernetes, которая может содержать один или несколько контейнеров.</li>
          <li><strong>Узлы (Nodes):</strong> Физические или виртуальные серверы в кластере Kubernetes.</li>
          <li><strong>Service:</strong> Обеспечивает доступ к подам через стабильный сетевой адрес.</li>
          <li><strong>ReplicaSet:</strong> Гарантирует, что заданное количество подов работает в кластере в любое время.</li>
        </ul>
      `,
      level: "JUNIOR"
    },
    {
      id: 39,
      question: "Что такое пулы данных в нагрузочном тестировании и как их использовать?",
      answer: `
        <p>Пулы данных — это наборы данных, которые используются для параметризации запросов в тестах, чтобы симулировать различные входные данные и избежать отправки однотипных запросов.</p>
        <p><strong>Зачем нужны пулы данных:</strong></p>
        <ul>
          <li>Они позволяют разнообразить запросы, обеспечивая более реалистичное тестирование.</li>
          <li>Помогают избежать кэширования запросов.</li>
          <li>Используются для тестирования больших объёмов данных.</li>
        </ul>
        <p><strong>Как использовать пулы данных в нагрузочном тестировании:</strong></p>
        <ol>
          <li>Подготовьте пул данных в виде файла (например, CSV).</li>
          <li>Настройте инструменты (JMeter, Locust) для использования данных из этого файла.</li>
        </ol>
        <p>Пример использования пула данных в JMeter:</p>
        <pre><code>
          user1,password1
          user2,password2
          user3,password3
        </code></pre>
      `,
      level: "MIDDLE"
    },
    {
      id: 40,
      question: "Скрипт для сбора логов",
      answer: `
        <p>Пример скрипта на Python для сбора логов:</p>
        <pre><code class="language-python">
          import os
          import time
  
          log_file = "/path/to/logfile.log"
  
          def follow_log(file_path):
              with open(file_path, 'r') as f:
                  f.seek(0, os.SEEK_END)
                  while True:
                      line = f.readline()
                      if not line:
                          time.sleep(0.1)
                          continue
                      yield line
  
          def write_logs_to_file(log_lines, output_file):
              with open(output_file, 'a') as f:
                  for line in log_lines:
                      f.write(line)
  
          if __name__ == "__main__":
              log_lines = follow_log(log_file)
              output_log_file = "/path/to/output_logfile.log"
              write_logs_to_file(log_lines, output_log_file)
        </code></pre>
        <p>Пример на Java:</p>
        <pre><code class="language-java">
          import java.io.IOException;
          import java.nio.file.*;
  
          public class LogCollector {
  
              public static void main(String[] args) {
                  Path logFile = Paths.get("/path/to/logfile.log");
                  Path outputLogFile = Paths.get("/path/to/output_logfile.log");
  
                  try {
                      WatchService watchService = FileSystems.getDefault().newWatchService();
                      logFile.getParent().register(watchService, StandardWatchEventKinds.ENTRY_MODIFY);
  
                      while (true) {
                          WatchKey key = watchService.take();
                          for (WatchEvent<?> event : key.pollEvents()) {
                              if (event.context().toString().equals(logFile.getFileName().toString())) {
                                  Files.lines(logFile)
                                      .forEach(line -> {
                                          try {
                                              Files.write(outputLogFile, (line + "\\n").getBytes(), StandardOpenOption.APPEND);
                                          } catch (IOException e) {
                                              e.printStackTrace();
                                          }
                                      });
                              }
                          }
                          key.reset();
                      }
                  } catch (IOException | InterruptedException e) {
                      e.printStackTrace();
                  }
              }
          }
        </code></pre>
      `,
      level: "MIDDLE"
    },
    {
      id: 41,
      question: "Как анализировать систему по количеству потоков, пулов, коннектов, времени работы GC, heap и non-heap?",
      answer: `
        <p><strong>1. Количество потоков (Threads):</strong> Используйте <code>jconsole</code> или <code>jstack</code> для мониторинга потоков в JVM.</p>
        <p><strong>2. Пулы потоков (Thread Pools):</strong> Анализируйте пулы потоков, чтобы избежать перегрузки.</p>
        <p><strong>3. Пулы соединений (Connection Pools):</strong> Контролируйте количество соединений к БД (например, с HikariCP).</p>
        <p><strong>4. Время работы GC (Garbage Collection):</strong> Используйте <code>jstat</code> или <code>VisualVM</code> для мониторинга.</p>
        <p><strong>5. Heap и Non-Heap память:</strong> Анализируйте состояние heap и non-heap памяти с помощью <code>jconsole</code> или <code>VisualVM</code>.</p>
      `,
      level: "MIDDLE"
    },
    {
      id: 42,
      question: "Как выявить долгие запросы в БД?",
      answer: `
        <p>Мониторинг медленных запросов можно выполнять с помощью системных таблиц или включения логов медленных запросов.</p>
        <p>Пример запроса для PostgreSQL:</p>
        <pre><code>
          SELECT pid, query, state, age(now(), query_start) AS duration
          FROM pg_stat_activity
          WHERE state = 'active'
          ORDER BY duration DESC;
        </code></pre>
      `,
      level: "MIDDLE"
    },
    {
      id: 43,
      question: "Как снять heap dump и thread dump?",
      answer: `
        <p><strong>1. Heap Dump:</strong> Используйте команду <code>jmap</code> для создания heap dump:</p>
        <pre><code>jmap -dump:live,format=b,file=heapdump.hprof &lt;pid&gt;</code></pre>
        <p><strong>2. Thread Dump:</strong> Используйте команду <code>jstack</code> для получения состояния потоков:</p>
        <pre><code>jstack -l &lt;pid&gt; > threaddump.txt</code></pre>
      `,
      level: "MIDDLE"
    },
    {
      id: 44,
      question: "INSERT и UPDATE в SQL",
      answer: `
        <p><strong>INSERT:</strong> Команда для добавления новых записей в таблицу:</p>
        <pre><code>
          INSERT INTO employees (first_name, last_name, age, department)
          VALUES ('John', 'Doe', 30, 'IT');
        </code></pre>
        <p><strong>UPDATE:</strong> Команда для обновления существующих записей:</p>
        <pre><code>
          UPDATE employees
          SET age = 31
          WHERE first_name = 'John' AND last_name = 'Doe';
        </code></pre>
      `,
      level: "MIDDLE"
    },
    {
      id: 45,
      question: "Как массово обновить данные в БД?",
      answer: `
        <p>Массовое обновление данных в базе данных можно выполнить с помощью <code>UPDATE</code>:</p>
        <pre><code>
          UPDATE employees
          SET department = 'Sales'
          WHERE department = 'Marketing';
        </code></pre>
      `,
      level: "MIDDLE"
    },
    {
      id: 46,
      question: "Что такое индекс и как с ним работать? Как проверять индексы в БД?",
      answer: `
        <p><strong>Индекс</strong> — это структура данных для ускорения поиска и сортировки данных в таблице.</p>
        <p><strong>Преимущества индексов:</strong></p>
        <ul>
          <li>Улучшают производительность запросов на выборку (SELECT).</li>
        </ul>
        <p>Пример создания индекса:</p>
        <pre><code>
          CREATE INDEX idx_employee_name ON employees (first_name, last_name);
        </code></pre>
      `,
      level: "MIDDLE"
    },
    {
      id: 47,
      question: "Что такое системные таблицы в БД?",
      answer: `
        <p>Системные таблицы — это таблицы, которые хранят метаинформацию о структуре базы данных и активных сессиях.</p>
        <p>Пример для PostgreSQL:</p>
        <pre><code>
          SELECT pid, usename, state, query
          FROM pg_stat_activity;
        </code></pre>
      `,
      level: "MIDDLE"
    }
  ];